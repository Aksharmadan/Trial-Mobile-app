{"file_contents":{"Mobile-Architect/client/screens/PredictionsScreen.tsx":{"content":"import React, { useState, useCallback } from \"react\";\nimport { View, ScrollView, RefreshControl, StyleSheet, Alert } from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useHeaderHeight } from \"@react-navigation/elements\";\nimport { useBottomTabBarHeight } from \"@react-navigation/bottom-tabs\";\nimport { useFocusEffect } from \"@react-navigation/native\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { Feather } from \"@expo/vector-icons\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { Card } from \"@/components/Card\";\nimport { HeatmapGrid } from \"@/components/HeatmapGrid\";\nimport { EmptyState } from \"@/components/EmptyState\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\nimport { getSavedLocations, SavedLocation } from \"@/lib/storage\";\n\ntype TimeSlotData = {\n  dayOfWeek: number;\n  hour: number;\n  averageWaitTime: number;\n  sampleCount: number;\n};\n\ntype BestTimeData = {\n  hour: number;\n  dayOfWeek: number;\n  estimatedWait: number;\n};\n\nconst DAYS_FULL = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n\nexport default function PredictionsScreen() {\n  const insets = useSafeAreaInsets();\n  const headerHeight = useHeaderHeight();\n  const tabBarHeight = useBottomTabBarHeight();\n  const { theme } = useTheme();\n  \n  const [savedLocations, setSavedLocations] = useState<SavedLocation[]>([]);\n  const [selectedLocationId, setSelectedLocationId] = useState<string | null>(null);\n  const [refreshing, setRefreshing] = useState(false);\n\n  const loadSavedLocations = useCallback(async () => {\n    const locations = await getSavedLocations();\n    setSavedLocations(locations);\n    if (locations.length > 0 && !selectedLocationId) {\n      setSelectedLocationId(locations[0].id);\n    }\n  }, [selectedLocationId]);\n\n  useFocusEffect(\n    useCallback(() => {\n      loadSavedLocations();\n    }, [loadSavedLocations])\n  );\n\n  const { data: timeSlots = [], refetch: refetchSlots } = useQuery<TimeSlotData[]>({\n    queryKey: [\"/api/locations\", selectedLocationId, \"history\"],\n    enabled: !!selectedLocationId,\n  });\n\n  const { data: bestTimes = [], refetch: refetchBestTimes } = useQuery<BestTimeData[]>({\n    queryKey: [\"/api/locations\", selectedLocationId, \"best-time\"],\n    enabled: !!selectedLocationId,\n  });\n\n  const handleRefresh = async () => {\n    setRefreshing(true);\n    await loadSavedLocations();\n    if (selectedLocationId) {\n      await refetchSlots();\n      await refetchBestTimes();\n    }\n    setRefreshing(false);\n  };\n\n  const handleCellPress = (dayOfWeek: number, hour: number, waitTime: number) => {\n    const day = DAYS_FULL[dayOfWeek];\n    const time = hour > 12 ? `${hour - 12}:00 PM` : hour === 12 ? \"12:00 PM\" : `${hour}:00 AM`;\n    Alert.alert(\n      `${day} at ${time}`,\n      waitTime > 0 ? `Average wait: ${waitTime} minutes` : \"No data available for this time slot\"\n    );\n  };\n\n  const formatHour = (hour: number) => {\n    if (hour === 12) return \"12:00 PM\";\n    if (hour > 12) return `${hour - 12}:00 PM`;\n    return `${hour}:00 AM`;\n  };\n\n  const selectedLocation = savedLocations.find((l) => l.id === selectedLocationId);\n\n  if (savedLocations.length === 0) {\n    return (\n      <View style={[styles.container, { backgroundColor: theme.backgroundRoot }]}>\n        <View style={{ paddingTop: headerHeight + Spacing[\"3xl\"], flex: 1, justifyContent: \"center\" }}>\n          <EmptyState\n            icon=\"heart\"\n            title=\"No Saved Locations\"\n            description=\"Save your favorite locations to see best time recommendations and patterns.\"\n          />\n        </View>\n      </View>\n    );\n  }\n\n  return (\n    <ScrollView\n      style={[styles.container, { backgroundColor: theme.backgroundRoot }]}\n      contentContainerStyle={{\n        paddingTop: headerHeight + Spacing.xl,\n        paddingBottom: tabBarHeight + Spacing[\"3xl\"],\n        paddingHorizontal: Spacing.lg,\n      }}\n      refreshControl={\n        <RefreshControl refreshing={refreshing} onRefresh={handleRefresh} tintColor={theme.primary} />\n      }\n    >\n      {selectedLocation ? (\n        <View style={styles.locationHeader}>\n          <Feather name=\"map-pin\" size={16} color={theme.primary} />\n          <ThemedText style={styles.locationName}>{selectedLocation.name}</ThemedText>\n        </View>\n      ) : null}\n\n      {bestTimes.length > 0 ? (\n        <Card elevation={1} style={styles.recommendationCard}>\n          <View style={styles.recommendationHeader}>\n            <View style={[styles.recommendationBadge, { backgroundColor: theme.success + \"20\" }]}>\n              <Feather name=\"clock\" size={16} color={theme.success} />\n            </View>\n            <ThemedText style={styles.recommendationTitle}>Best Time to Visit</ThemedText>\n          </View>\n          <View style={styles.bestTimesList}>\n            {bestTimes.slice(0, 3).map((bt, index) => (\n              <View key={index} style={[styles.bestTimeItem, { backgroundColor: theme.backgroundDefault }]}>\n                <View style={styles.bestTimeInfo}>\n                  <ThemedText style={styles.bestTimeDay}>{DAYS_FULL[bt.dayOfWeek]}</ThemedText>\n                  <ThemedText style={[styles.bestTimeHour, { color: theme.textSecondary }]}>\n                    {formatHour(bt.hour)}\n                  </ThemedText>\n                </View>\n                <View style={[styles.waitBadge, { backgroundColor: theme.success + \"20\" }]}>\n                  <ThemedText style={[styles.waitText, { color: theme.success }]}>\n                    ~{bt.estimatedWait} min\n                  </ThemedText>\n                </View>\n              </View>\n            ))}\n          </View>\n        </Card>\n      ) : (\n        <Card elevation={1} style={styles.recommendationCard}>\n          <View style={styles.noDataContent}>\n            <Feather name=\"bar-chart-2\" size={32} color={theme.textSecondary} />\n            <ThemedText style={[styles.noDataText, { color: theme.textSecondary }]}>\n              Not enough data yet. Check in to help build predictions!\n            </ThemedText>\n          </View>\n        </Card>\n      )}\n\n      <ThemedText type=\"h4\" style={styles.sectionTitle}>\n        Weekly Patterns\n      </ThemedText>\n      <Card elevation={1} style={styles.heatmapCard}>\n        {timeSlots.length > 0 ? (\n          <HeatmapGrid data={timeSlots} onCellPress={handleCellPress} />\n        ) : (\n          <View style={styles.noDataContent}>\n            <ThemedText style={[styles.noDataText, { color: theme.textSecondary }]}>\n              No historical data available yet\n            </ThemedText>\n          </View>\n        )}\n        <View style={styles.legend}>\n          <View style={styles.legendItem}>\n            <View style={[styles.legendDot, { backgroundColor: theme.success + \"60\" }]} />\n            <ThemedText style={[styles.legendText, { color: theme.textSecondary }]}>Low wait</ThemedText>\n          </View>\n          <View style={styles.legendItem}>\n            <View style={[styles.legendDot, { backgroundColor: theme.warning + \"80\" }]} />\n            <ThemedText style={[styles.legendText, { color: theme.textSecondary }]}>Medium</ThemedText>\n          </View>\n          <View style={styles.legendItem}>\n            <View style={[styles.legendDot, { backgroundColor: theme.error + \"A0\" }]} />\n            <ThemedText style={[styles.legendText, { color: theme.textSecondary }]}>High wait</ThemedText>\n          </View>\n        </View>\n      </Card>\n    </ScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  locationHeader: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.sm,\n    marginBottom: Spacing.lg,\n  },\n  locationName: {\n    fontSize: 16,\n    fontWeight: \"500\",\n  },\n  recommendationCard: {\n    marginBottom: Spacing[\"2xl\"],\n  },\n  recommendationHeader: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.md,\n    marginBottom: Spacing.lg,\n  },\n  recommendationBadge: {\n    width: 36,\n    height: 36,\n    borderRadius: BorderRadius.sm,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  recommendationTitle: {\n    fontSize: 18,\n    fontWeight: \"600\",\n  },\n  bestTimesList: {\n    gap: Spacing.sm,\n  },\n  bestTimeItem: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    padding: Spacing.md,\n    borderRadius: BorderRadius.sm,\n  },\n  bestTimeInfo: {},\n  bestTimeDay: {\n    fontSize: 14,\n    fontWeight: \"500\",\n  },\n  bestTimeHour: {\n    fontSize: 12,\n    marginTop: 2,\n  },\n  waitBadge: {\n    paddingHorizontal: Spacing.sm,\n    paddingVertical: Spacing.xs,\n    borderRadius: BorderRadius.xs,\n  },\n  waitText: {\n    fontSize: 12,\n    fontWeight: \"500\",\n  },\n  noDataContent: {\n    alignItems: \"center\",\n    paddingVertical: Spacing.xl,\n    gap: Spacing.md,\n  },\n  noDataText: {\n    fontSize: 14,\n    textAlign: \"center\",\n  },\n  sectionTitle: {\n    marginBottom: Spacing.md,\n  },\n  heatmapCard: {\n    marginBottom: Spacing.lg,\n  },\n  legend: {\n    flexDirection: \"row\",\n    justifyContent: \"center\",\n    gap: Spacing.lg,\n    marginTop: Spacing.lg,\n    paddingTop: Spacing.lg,\n    borderTopWidth: 1,\n    borderTopColor: \"rgba(0,0,0,0.05)\",\n  },\n  legendItem: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.xs,\n  },\n  legendDot: {\n    width: 12,\n    height: 12,\n    borderRadius: 2,\n  },\n  legendText: {\n    fontSize: 12,\n  },\n});\n","path":null,"size_bytes":9437,"size_tokens":null},"Mobile-Architect/client/components/LocationCard.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet, Pressable } from \"react-native\";\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from \"react-native-reanimated\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { CrowdIndicator } from \"@/components/CrowdIndicator\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\n\ninterface LocationCardProps {\n  name: string;\n  address: string;\n  waitTime?: number;\n  queueSize?: number;\n  onPress: () => void;\n}\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nexport function LocationCard({ name, address, waitTime, queueSize, onPress }: LocationCardProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handlePressIn = () => {\n    scale.value = withSpring(0.98, { damping: 15, stiffness: 150 });\n  };\n\n  const handlePressOut = () => {\n    scale.value = withSpring(1, { damping: 15, stiffness: 150 });\n  };\n\n  return (\n    <AnimatedPressable\n      onPress={onPress}\n      onPressIn={handlePressIn}\n      onPressOut={handlePressOut}\n      style={[\n        styles.card,\n        { backgroundColor: theme.backgroundDefault },\n        animatedStyle,\n      ]}\n    >\n      <View style={styles.content}>\n        <View style={styles.header}>\n          <View style={styles.titleRow}>\n            {queueSize !== undefined ? <CrowdIndicator queueSize={queueSize} /> : null}\n            <ThemedText style={styles.name} numberOfLines={1}>\n              {name}\n            </ThemedText>\n          </View>\n          <Feather name=\"chevron-right\" size={20} color={theme.textSecondary} />\n        </View>\n        <View style={styles.addressRow}>\n          <Feather name=\"map-pin\" size={14} color={theme.textSecondary} />\n          <ThemedText style={[styles.address, { color: theme.textSecondary }]} numberOfLines={1}>\n            {address}\n          </ThemedText>\n        </View>\n        {waitTime !== undefined ? (\n          <View style={[styles.waitBadge, { backgroundColor: theme.backgroundSecondary }]}>\n            <Feather name=\"clock\" size={12} color={theme.primary} />\n            <ThemedText style={[styles.waitText, { color: theme.primary }]}>\n              ~{waitTime} min wait\n            </ThemedText>\n          </View>\n        ) : null}\n      </View>\n    </AnimatedPressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  card: {\n    borderRadius: BorderRadius.lg,\n    padding: Spacing.lg,\n    marginBottom: Spacing.md,\n  },\n  content: {\n    gap: Spacing.sm,\n  },\n  header: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n  },\n  titleRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.sm,\n    flex: 1,\n  },\n  name: {\n    fontSize: 16,\n    fontWeight: \"600\",\n    flex: 1,\n  },\n  addressRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.xs,\n  },\n  address: {\n    fontSize: 14,\n    flex: 1,\n  },\n  waitBadge: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.xs,\n    paddingHorizontal: Spacing.sm,\n    paddingVertical: Spacing.xs,\n    borderRadius: BorderRadius.xs,\n    alignSelf: \"flex-start\",\n    marginTop: Spacing.xs,\n  },\n  waitText: {\n    fontSize: 12,\n    fontWeight: \"500\",\n  },\n});\n","path":null,"size_bytes":3427,"size_tokens":null},"Mobile-Architect/server/prediction.ts":{"content":"import { storage } from \"./storage\";\nimport type { Checkin, TimeSlot, Location } from \"@shared/schema\";\n\ninterface PredictionResult {\n  estimatedWaitTime: number;\n  confidence: number;\n  trend: \"increasing\" | \"stable\" | \"decreasing\";\n  currentQueueSize: number;\n}\n\nexport async function calculatePrediction(locationId: string): Promise<PredictionResult> {\n  const location = await storage.getLocation(locationId);\n  if (!location) {\n    return { estimatedWaitTime: 0, confidence: 0, trend: \"stable\", currentQueueSize: 0 };\n  }\n\n  const recentCheckins = await storage.getRecentCheckins(locationId, 60);\n  const now = new Date();\n  const dayOfWeek = now.getDay();\n  const hour = now.getHours();\n\n  const historicalSlot = await storage.getTimeSlot(locationId, dayOfWeek, hour);\n\n  const liveData = calculateLiveMetrics(recentCheckins, location);\n  const historicalData = calculateHistoricalMetrics(historicalSlot);\n  const result = combineMetrics(liveData, historicalData, location);\n\n  await storage.createPrediction({\n    locationId,\n    estimatedWaitTime: result.estimatedWaitTime,\n    confidence: result.confidence,\n    trend: result.trend,\n    currentQueueSize: result.currentQueueSize,\n  });\n\n  return result;\n}\n\nfunction calculateLiveMetrics(checkins: Checkin[], location: Location) {\n  if (checkins.length === 0) {\n    return { queueSize: 0, weight: 0, trend: \"stable\" as const };\n  }\n\n  const now = Date.now();\n  let weightedSum = 0;\n  let weightSum = 0;\n\n  checkins.forEach((checkin) => {\n    const age = (now - new Date(checkin.createdAt).getTime()) / (60 * 1000);\n    const weight = Math.exp(-age / 30) * (checkin.confidence || 1);\n    weightedSum += checkin.peopleAhead * weight;\n    weightSum += weight;\n  });\n\n  const queueSize = weightSum > 0 ? weightedSum / weightSum : 0;\n\n  const trend = calculateTrend(checkins);\n\n  return { queueSize, weight: Math.min(checkins.length / 5, 1), trend };\n}\n\nfunction calculateTrend(checkins: Checkin[]): \"increasing\" | \"stable\" | \"decreasing\" {\n  if (checkins.length < 3) return \"stable\";\n\n  const recent = checkins.slice(0, Math.ceil(checkins.length / 2));\n  const older = checkins.slice(Math.ceil(checkins.length / 2));\n\n  const recentAvg = recent.reduce((sum, c) => sum + c.peopleAhead, 0) / recent.length;\n  const olderAvg = older.reduce((sum, c) => sum + c.peopleAhead, 0) / older.length;\n\n  const diff = recentAvg - olderAvg;\n  const threshold = 2;\n\n  if (diff > threshold) return \"increasing\";\n  if (diff < -threshold) return \"decreasing\";\n  return \"stable\";\n}\n\nfunction calculateHistoricalMetrics(slot: TimeSlot | undefined) {\n  if (!slot || !slot.sampleCount || slot.sampleCount < 3) {\n    return { averageWait: 0, averageQueue: 0, weight: 0 };\n  }\n\n  const reliability = Math.min(slot.sampleCount / 20, 1);\n  return {\n    averageWait: slot.averageWaitTime || 0,\n    averageQueue: slot.averagePeopleCount || 0,\n    weight: reliability,\n  };\n}\n\nfunction combineMetrics(\n  live: { queueSize: number; weight: number; trend: \"increasing\" | \"stable\" | \"decreasing\" },\n  historical: { averageWait: number; averageQueue: number; weight: number },\n  location: Location\n): PredictionResult {\n  const serviceTime = location.averageServiceTime || 5;\n\n  const totalWeight = live.weight + historical.weight;\n  \n  if (totalWeight === 0) {\n    return {\n      estimatedWaitTime: 0,\n      confidence: 0.1,\n      trend: \"stable\",\n      currentQueueSize: 0,\n    };\n  }\n\n  let estimatedWait: number;\n  let queueSize: number;\n  \n  if (live.weight > 0.5) {\n    queueSize = live.queueSize;\n    estimatedWait = Math.round(queueSize * serviceTime);\n  } else if (historical.weight > 0.5) {\n    queueSize = historical.averageQueue;\n    estimatedWait = Math.round(historical.averageWait);\n  } else {\n    const liveNorm = live.weight / totalWeight;\n    const histNorm = historical.weight / totalWeight;\n    \n    queueSize = live.queueSize * liveNorm + historical.averageQueue * histNorm;\n    estimatedWait = Math.round(\n      (live.queueSize * serviceTime * liveNorm) + (historical.averageWait * histNorm)\n    );\n  }\n\n  const confidence = Math.min(0.3 + totalWeight * 0.5, 0.95);\n\n  return {\n    estimatedWaitTime: Math.max(0, estimatedWait),\n    confidence: Math.round(confidence * 100) / 100,\n    trend: live.trend,\n    currentQueueSize: Math.round(queueSize),\n  };\n}\n\nexport async function updateTimeSlotData(locationId: string, peopleAhead: number): Promise<void> {\n  const now = new Date();\n  const dayOfWeek = now.getDay();\n  const hour = now.getHours();\n  \n  const location = await storage.getLocation(locationId);\n  if (!location) return;\n\n  const serviceTime = location.averageServiceTime || 5;\n  const waitTime = peopleAhead * serviceTime;\n\n  const existing = await storage.getTimeSlot(locationId, dayOfWeek, hour);\n  \n  if (existing) {\n    const newCount = (existing.sampleCount || 0) + 1;\n    const oldWeight = (existing.sampleCount || 0) / newCount;\n    const newWeight = 1 / newCount;\n    \n    await storage.upsertTimeSlot({\n      locationId,\n      dayOfWeek,\n      hour,\n      averageWaitTime: ((existing.averageWaitTime || 0) * oldWeight) + (waitTime * newWeight),\n      averagePeopleCount: ((existing.averagePeopleCount || 0) * oldWeight) + (peopleAhead * newWeight),\n      sampleCount: newCount,\n    });\n  } else {\n    await storage.upsertTimeSlot({\n      locationId,\n      dayOfWeek,\n      hour,\n      averageWaitTime: waitTime,\n      averagePeopleCount: peopleAhead,\n      sampleCount: 1,\n    });\n  }\n}\n\nexport async function getBestTimeToVisit(locationId: string): Promise<{ hour: number; dayOfWeek: number; estimatedWait: number }[]> {\n  const slots = await storage.getTimeSlots(locationId);\n  \n  if (slots.length === 0) {\n    return [];\n  }\n\n  const validSlots = slots\n    .filter(s => (s.sampleCount || 0) >= 2)\n    .sort((a, b) => (a.averageWaitTime || 0) - (b.averageWaitTime || 0))\n    .slice(0, 5);\n\n  return validSlots.map(s => ({\n    hour: s.hour,\n    dayOfWeek: s.dayOfWeek,\n    estimatedWait: Math.round(s.averageWaitTime || 0),\n  }));\n}\n","path":null,"size_bytes":5999,"size_tokens":null},"Mobile-Architect/babel.config.js":{"content":"module.exports = function (api) {\n  api.cache(true);\n  return {\n    presets: [\"babel-preset-expo\"],\n    plugins: [\n      [\n        \"module-resolver\",\n        {\n          root: [\"./\"],\n          alias: {\n            \"@\": \"./client\",\n            \"@shared\": \"./shared\",\n          },\n          extensions: [\".ios.js\", \".android.js\", \".js\", \".ts\", \".tsx\", \".json\"],\n        },\n      ],\n      \"react-native-reanimated/plugin\",\n    ],\n  };\n};\n","path":null,"size_bytes":436,"size_tokens":null},"Mobile-Architect/client/components/Card.tsx":{"content":"import React from \"react\";\nimport { StyleSheet, Pressable, ViewStyle } from \"react-native\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  WithSpringConfig,\n} from \"react-native-reanimated\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\n\ninterface CardProps {\n  elevation?: number;\n  title?: string;\n  description?: string;\n  children?: React.ReactNode;\n  onPress?: () => void;\n  style?: ViewStyle;\n}\n\nconst springConfig: WithSpringConfig = {\n  damping: 15,\n  mass: 0.3,\n  stiffness: 150,\n  overshootClamping: true,\n  energyThreshold: 0.001,\n};\n\nconst getBackgroundColorForElevation = (\n  elevation: number,\n  theme: any,\n): string => {\n  switch (elevation) {\n    case 1:\n      return theme.backgroundDefault;\n    case 2:\n      return theme.backgroundSecondary;\n    case 3:\n      return theme.backgroundTertiary;\n    default:\n      return theme.backgroundRoot;\n  }\n};\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nexport function Card({\n  elevation = 1,\n  title,\n  description,\n  children,\n  onPress,\n  style,\n}: CardProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const cardBackgroundColor = getBackgroundColorForElevation(elevation, theme);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handlePressIn = () => {\n    scale.value = withSpring(0.98, springConfig);\n  };\n\n  const handlePressOut = () => {\n    scale.value = withSpring(1, springConfig);\n  };\n\n  return (\n    <AnimatedPressable\n      onPress={onPress}\n      onPressIn={handlePressIn}\n      onPressOut={handlePressOut}\n      style={[\n        styles.card,\n        {\n          backgroundColor: cardBackgroundColor,\n        },\n        animatedStyle,\n        style,\n      ]}\n    >\n      {title ? (\n        <ThemedText type=\"h4\" style={styles.cardTitle}>\n          {title}\n        </ThemedText>\n      ) : null}\n      {description ? (\n        <ThemedText type=\"small\" style={styles.cardDescription}>\n          {description}\n        </ThemedText>\n      ) : null}\n      {children}\n    </AnimatedPressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  card: {\n    padding: Spacing.xl,\n    borderRadius: BorderRadius[\"2xl\"],\n  },\n  cardTitle: {\n    marginBottom: Spacing.sm,\n  },\n  cardDescription: {\n    opacity: 0.7,\n  },\n});\n","path":null,"size_bytes":2437,"size_tokens":null},"Mobile-Architect/client/components/ErrorBoundary.tsx":{"content":"import React, { Component, ComponentType, PropsWithChildren } from \"react\";\nimport { ErrorFallback, ErrorFallbackProps } from \"@/components/ErrorFallback\";\n\nexport type ErrorBoundaryProps = PropsWithChildren<{\n  FallbackComponent?: ComponentType<ErrorFallbackProps>;\n  onError?: (error: Error, stackTrace: string) => void;\n}>;\n\ntype ErrorBoundaryState = { error: Error | null };\n\n/**\n * This is a special case for for using the class components. Error boundaries must be class components because React only provides error boundary functionality through lifecycle methods (componentDidCatch and getDerivedStateFromError) which are not available in functional components.\n * https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary\n */\n\nexport class ErrorBoundary extends Component<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  state: ErrorBoundaryState = { error: null };\n\n  static defaultProps: {\n    FallbackComponent: ComponentType<ErrorFallbackProps>;\n  } = {\n    FallbackComponent: ErrorFallback,\n  };\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { error };\n  }\n\n  componentDidCatch(error: Error, info: { componentStack: string }): void {\n    if (typeof this.props.onError === \"function\") {\n      this.props.onError(error, info.componentStack);\n    }\n  }\n\n  resetError = (): void => {\n    this.setState({ error: null });\n  };\n\n  render() {\n    const { FallbackComponent } = this.props;\n\n    return this.state.error && FallbackComponent ? (\n      <FallbackComponent\n        error={this.state.error}\n        resetError={this.resetError}\n      />\n    ) : (\n      this.props.children\n    );\n  }\n}\n","path":null,"size_bytes":1674,"size_tokens":null},"Mobile-Architect/client/components/TrendIndicator.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet } from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\n\ninterface TrendIndicatorProps {\n  trend: \"increasing\" | \"stable\" | \"decreasing\";\n}\n\nfunction getTrendInfo(trend: string, theme: any) {\n  switch (trend) {\n    case \"increasing\":\n      return { icon: \"arrow-up\" as const, color: theme.error, label: \"Increasing\" };\n    case \"decreasing\":\n      return { icon: \"arrow-down\" as const, color: theme.success, label: \"Decreasing\" };\n    default:\n      return { icon: \"arrow-right\" as const, color: theme.info, label: \"Stable\" };\n  }\n}\n\nexport function TrendIndicator({ trend }: TrendIndicatorProps) {\n  const { theme } = useTheme();\n  const info = getTrendInfo(trend, theme);\n\n  return (\n    <View style={[styles.container, { backgroundColor: theme.backgroundDefault }]}>\n      <Feather name={info.icon} size={18} color={info.color} />\n      <ThemedText style={[styles.label, { color: info.color }]}>\n        {info.label}\n      </ThemedText>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.md,\n    paddingVertical: Spacing.sm,\n    borderRadius: BorderRadius.full,\n    gap: Spacing.xs,\n  },\n  label: {\n    fontSize: 14,\n    fontWeight: \"500\",\n  },\n});\n","path":null,"size_bytes":1478,"size_tokens":null},"Mobile-Architect/client/components/CategoryChip.tsx":{"content":"import React from \"react\";\nimport { StyleSheet, Pressable } from \"react-native\";\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from \"react-native-reanimated\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\n\ninterface CategoryChipProps {\n  label: string;\n  icon: string;\n  isSelected: boolean;\n  onPress: () => void;\n}\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nexport function CategoryChip({ label, icon, isSelected, onPress }: CategoryChipProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handlePressIn = () => {\n    scale.value = withSpring(0.95, { damping: 15, stiffness: 150 });\n  };\n\n  const handlePressOut = () => {\n    scale.value = withSpring(1, { damping: 15, stiffness: 150 });\n  };\n\n  return (\n    <AnimatedPressable\n      onPress={onPress}\n      onPressIn={handlePressIn}\n      onPressOut={handlePressOut}\n      style={[\n        styles.chip,\n        {\n          backgroundColor: isSelected ? theme.primary : theme.backgroundDefault,\n          borderColor: isSelected ? theme.primary : theme.border,\n        },\n        animatedStyle,\n      ]}\n    >\n      <Feather\n        name={icon as any}\n        size={16}\n        color={isSelected ? \"#FFFFFF\" : theme.text}\n      />\n      <ThemedText\n        style={[\n          styles.label,\n          { color: isSelected ? \"#FFFFFF\" : theme.text },\n        ]}\n      >\n        {label}\n      </ThemedText>\n    </AnimatedPressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  chip: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.sm,\n    borderRadius: BorderRadius.full,\n    borderWidth: 1,\n    gap: Spacing.sm,\n    marginRight: Spacing.sm,\n  },\n  label: {\n    fontSize: 14,\n    fontWeight: \"500\",\n  },\n});\n","path":null,"size_bytes":2065,"size_tokens":null},"Mobile-Architect/client/hooks/useScreenOptions.ts":{"content":"import { Platform } from \"react-native\";\nimport { NativeStackNavigationOptions } from \"@react-navigation/native-stack\";\nimport { isLiquidGlassAvailable } from \"expo-glass-effect\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\n\ninterface UseScreenOptionsParams {\n  transparent?: boolean;\n}\n\nexport function useScreenOptions({\n  transparent = true,\n}: UseScreenOptionsParams = {}): NativeStackNavigationOptions {\n  const { theme, isDark } = useTheme();\n\n  return {\n    headerTitleAlign: \"center\",\n    headerTransparent: transparent,\n    headerBlurEffect: isDark ? \"dark\" : \"light\",\n    headerTintColor: theme.text,\n    headerStyle: {\n      backgroundColor: Platform.select({\n        ios: undefined,\n        android: theme.backgroundRoot,\n        web: theme.backgroundRoot,\n      }),\n    },\n    gestureEnabled: true,\n    gestureDirection: \"horizontal\",\n    fullScreenGestureEnabled: isLiquidGlassAvailable() ? false : true,\n    contentStyle: {\n      backgroundColor: theme.backgroundRoot,\n    },\n  };\n}\n","path":null,"size_bytes":1000,"size_tokens":null},"Mobile-Architect/client/components/HeaderTitle.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet, Image } from \"react-native\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { Spacing } from \"@/constants/theme\";\n\ninterface HeaderTitleProps {\n  title: string;\n}\n\nexport function HeaderTitle({ title }: HeaderTitleProps) {\n  return (\n    <View style={styles.container}>\n      <Image\n        source={require(\"../../assets/images/icon.png\")}\n        style={styles.icon}\n        resizeMode=\"contain\"\n      />\n      <ThemedText style={styles.title}>{title}</ThemedText>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"flex-start\",\n  },\n  icon: {\n    width: 28,\n    height: 28,\n    marginRight: Spacing.sm,\n  },\n  title: {\n    fontSize: 17,\n    fontWeight: \"600\",\n  },\n});\n","path":null,"size_bytes":832,"size_tokens":null},"Mobile-Architect/server/db.ts":{"content":"import { drizzle } from \"drizzle-orm/node-postgres\";\nimport pg from \"pg\";\nimport * as schema from \"@shared/schema\";\n\nconst { Pool } = pg;\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\n    \"DATABASE_URL must be set. Did you forget to provision a database?\",\n  );\n}\n\nexport const pool = new Pool({ connectionString: process.env.DATABASE_URL });\nexport const db = drizzle(pool, { schema });\n","path":null,"size_bytes":395,"size_tokens":null},"Mobile-Architect/client/hooks/useColorScheme.web.ts":{"content":"import { useEffect, useState } from \"react\";\nimport { useColorScheme as useRNColorScheme } from \"react-native\";\n\n/**\n * To support static rendering, this value needs to be re-calculated on the client side for web\n */\nexport function useColorScheme() {\n  const [hasHydrated, setHasHydrated] = useState(false);\n\n  useEffect(() => {\n    setHasHydrated(true);\n  }, []);\n\n  const colorScheme = useRNColorScheme();\n\n  if (hasHydrated) {\n    return colorScheme;\n  }\n\n  return \"light\";\n}\n","path":null,"size_bytes":480,"size_tokens":null},"Mobile-Architect/client/lib/device.ts":{"content":"import AsyncStorage from \"@react-native-async-storage/async-storage\";\nimport * as Crypto from \"expo-crypto\";\n\nconst DEVICE_ID_KEY = \"@queuesense_device_id\";\n\nexport async function getDeviceId(): Promise<string> {\n  try {\n    let deviceId = await AsyncStorage.getItem(DEVICE_ID_KEY);\n    if (!deviceId) {\n      deviceId = Crypto.randomUUID();\n      await AsyncStorage.setItem(DEVICE_ID_KEY, deviceId);\n    }\n    return deviceId;\n  } catch {\n    return Crypto.randomUUID();\n  }\n}\n\nexport async function clearDeviceId(): Promise<void> {\n  try {\n    await AsyncStorage.removeItem(DEVICE_ID_KEY);\n  } catch {\n  }\n}\n","path":null,"size_bytes":610,"size_tokens":null},"Mobile-Architect/shared/schema.ts":{"content":"import { sql, relations } from \"drizzle-orm\";\nimport { pgTable, text, varchar, integer, timestamp, real, boolean, index } from \"drizzle-orm/pg-core\";\nimport { createInsertSchema, createSelectSchema } from \"drizzle-zod\";\nimport { z } from \"zod\";\n\nexport const locationTypes = pgTable(\"location_types\", {\n  id: varchar(\"id\").primaryKey().default(sql`gen_random_uuid()`),\n  name: text(\"name\").notNull(),\n  icon: text(\"icon\").notNull(),\n  createdAt: timestamp(\"created_at\").defaultNow().notNull(),\n});\n\nexport const locations = pgTable(\"locations\", {\n  id: varchar(\"id\").primaryKey().default(sql`gen_random_uuid()`),\n  name: text(\"name\").notNull(),\n  address: text(\"address\").notNull(),\n  typeId: varchar(\"type_id\").notNull().references(() => locationTypes.id),\n  latitude: real(\"latitude\"),\n  longitude: real(\"longitude\"),\n  averageServiceTime: integer(\"average_service_time\").default(5),\n  isActive: boolean(\"is_active\").default(true),\n  createdAt: timestamp(\"created_at\").defaultNow().notNull(),\n  updatedAt: timestamp(\"updated_at\").defaultNow().notNull(),\n}, (table) => [\n  index(\"locations_type_idx\").on(table.typeId),\n  index(\"locations_active_idx\").on(table.isActive),\n]);\n\nexport const checkins = pgTable(\"checkins\", {\n  id: varchar(\"id\").primaryKey().default(sql`gen_random_uuid()`),\n  locationId: varchar(\"location_id\").notNull().references(() => locations.id),\n  deviceId: text(\"device_id\").notNull(),\n  peopleAhead: integer(\"people_ahead\").notNull(),\n  queueStage: text(\"queue_stage\").default(\"waiting\"),\n  confidence: real(\"confidence\").default(1.0),\n  createdAt: timestamp(\"created_at\").defaultNow().notNull(),\n}, (table) => [\n  index(\"checkins_location_idx\").on(table.locationId),\n  index(\"checkins_device_idx\").on(table.deviceId),\n  index(\"checkins_created_idx\").on(table.createdAt),\n]);\n\nexport const timeSlots = pgTable(\"time_slots\", {\n  id: varchar(\"id\").primaryKey().default(sql`gen_random_uuid()`),\n  locationId: varchar(\"location_id\").notNull().references(() => locations.id),\n  dayOfWeek: integer(\"day_of_week\").notNull(),\n  hour: integer(\"hour\").notNull(),\n  averageWaitTime: real(\"average_wait_time\").default(0),\n  averagePeopleCount: real(\"average_people_count\").default(0),\n  sampleCount: integer(\"sample_count\").default(0),\n  updatedAt: timestamp(\"updated_at\").defaultNow().notNull(),\n}, (table) => [\n  index(\"time_slots_location_idx\").on(table.locationId),\n  index(\"time_slots_day_hour_idx\").on(table.dayOfWeek, table.hour),\n]);\n\nexport const predictions = pgTable(\"predictions\", {\n  id: varchar(\"id\").primaryKey().default(sql`gen_random_uuid()`),\n  locationId: varchar(\"location_id\").notNull().references(() => locations.id),\n  estimatedWaitTime: integer(\"estimated_wait_time\").notNull(),\n  confidence: real(\"confidence\").default(0.5),\n  trend: text(\"trend\").default(\"stable\"),\n  currentQueueSize: integer(\"current_queue_size\").default(0),\n  createdAt: timestamp(\"created_at\").defaultNow().notNull(),\n}, (table) => [\n  index(\"predictions_location_idx\").on(table.locationId),\n  index(\"predictions_created_idx\").on(table.createdAt),\n]);\n\nexport const locationTypesRelations = relations(locationTypes, ({ many }) => ({\n  locations: many(locations),\n}));\n\nexport const locationsRelations = relations(locations, ({ one, many }) => ({\n  type: one(locationTypes, {\n    fields: [locations.typeId],\n    references: [locationTypes.id],\n  }),\n  checkins: many(checkins),\n  timeSlots: many(timeSlots),\n  predictions: many(predictions),\n}));\n\nexport const checkinsRelations = relations(checkins, ({ one }) => ({\n  location: one(locations, {\n    fields: [checkins.locationId],\n    references: [locations.id],\n  }),\n}));\n\nexport const timeSlotsRelations = relations(timeSlots, ({ one }) => ({\n  location: one(locations, {\n    fields: [timeSlots.locationId],\n    references: [locations.id],\n  }),\n}));\n\nexport const predictionsRelations = relations(predictions, ({ one }) => ({\n  location: one(locations, {\n    fields: [predictions.locationId],\n    references: [locations.id],\n  }),\n}));\n\nexport const insertLocationTypeSchema = createInsertSchema(locationTypes).pick({\n  name: true,\n  icon: true,\n});\n\nexport const insertLocationSchema = createInsertSchema(locations).pick({\n  name: true,\n  address: true,\n  typeId: true,\n  latitude: true,\n  longitude: true,\n  averageServiceTime: true,\n});\n\nexport const insertCheckinSchema = createInsertSchema(checkins).pick({\n  locationId: true,\n  deviceId: true,\n  peopleAhead: true,\n  queueStage: true,\n});\n\nexport const insertTimeSlotSchema = createInsertSchema(timeSlots).pick({\n  locationId: true,\n  dayOfWeek: true,\n  hour: true,\n  averageWaitTime: true,\n  averagePeopleCount: true,\n  sampleCount: true,\n});\n\nexport const insertPredictionSchema = createInsertSchema(predictions).pick({\n  locationId: true,\n  estimatedWaitTime: true,\n  confidence: true,\n  trend: true,\n  currentQueueSize: true,\n});\n\nexport type LocationType = typeof locationTypes.$inferSelect;\nexport type InsertLocationType = z.infer<typeof insertLocationTypeSchema>;\n\nexport type Location = typeof locations.$inferSelect;\nexport type InsertLocation = z.infer<typeof insertLocationSchema>;\n\nexport type Checkin = typeof checkins.$inferSelect;\nexport type InsertCheckin = z.infer<typeof insertCheckinSchema>;\n\nexport type TimeSlot = typeof timeSlots.$inferSelect;\nexport type InsertTimeSlot = z.infer<typeof insertTimeSlotSchema>;\n\nexport type Prediction = typeof predictions.$inferSelect;\nexport type InsertPrediction = z.infer<typeof insertPredictionSchema>;\n","path":null,"size_bytes":5482,"size_tokens":null},"Mobile-Architect/client/components/Button.tsx":{"content":"import React, { ReactNode } from \"react\";\nimport { StyleSheet, Pressable, ViewStyle, StyleProp } from \"react-native\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  WithSpringConfig,\n} from \"react-native-reanimated\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { BorderRadius, Spacing } from \"@/constants/theme\";\n\ninterface ButtonProps {\n  onPress?: () => void;\n  children: ReactNode;\n  style?: StyleProp<ViewStyle>;\n  disabled?: boolean;\n}\n\nconst springConfig: WithSpringConfig = {\n  damping: 15,\n  mass: 0.3,\n  stiffness: 150,\n  overshootClamping: true,\n  energyThreshold: 0.001,\n};\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nexport function Button({\n  onPress,\n  children,\n  style,\n  disabled = false,\n}: ButtonProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handlePressIn = () => {\n    if (!disabled) {\n      scale.value = withSpring(0.98, springConfig);\n    }\n  };\n\n  const handlePressOut = () => {\n    if (!disabled) {\n      scale.value = withSpring(1, springConfig);\n    }\n  };\n\n  return (\n    <AnimatedPressable\n      onPress={disabled ? undefined : onPress}\n      onPressIn={handlePressIn}\n      onPressOut={handlePressOut}\n      disabled={disabled}\n      style={[\n        styles.button,\n        {\n          backgroundColor: theme.link,\n          opacity: disabled ? 0.5 : 1,\n        },\n        style,\n        animatedStyle,\n      ]}\n    >\n      <ThemedText\n        type=\"body\"\n        style={[styles.buttonText, { color: theme.buttonText }]}\n      >\n        {children}\n      </ThemedText>\n    </AnimatedPressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.full,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  buttonText: {\n    fontWeight: \"600\",\n  },\n});\n","path":null,"size_bytes":2014,"size_tokens":null},"Mobile-Architect/client/index.js":{"content":"import { registerRootComponent } from \"expo\";\n\nimport App from \"@/App\";\n\nregisterRootComponent(App);\n","path":null,"size_bytes":101,"size_tokens":null},"Mobile-Architect/client/navigation/MainTabNavigator.tsx":{"content":"import React from \"react\";\nimport { createBottomTabNavigator } from \"@react-navigation/bottom-tabs\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { BlurView } from \"expo-blur\";\nimport { Platform, StyleSheet, View, Pressable } from \"react-native\";\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from \"react-native-reanimated\";\nimport HomeStackNavigator from \"@/navigation/HomeStackNavigator\";\nimport PredictionsStackNavigator from \"@/navigation/PredictionsStackNavigator\";\nimport HistoryStackNavigator from \"@/navigation/HistoryStackNavigator\";\nimport SettingsStackNavigator from \"@/navigation/SettingsStackNavigator\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius, Shadows } from \"@/constants/theme\";\n\nexport type MainTabParamList = {\n  HomeTab: undefined;\n  PredictionsTab: undefined;\n  HistoryTab: undefined;\n  SettingsTab: undefined;\n};\n\nconst Tab = createBottomTabNavigator<MainTabParamList>();\n\nexport default function MainTabNavigator() {\n  const { theme, isDark } = useTheme();\n\n  return (\n    <Tab.Navigator\n      initialRouteName=\"HomeTab\"\n      screenOptions={{\n        tabBarActiveTintColor: theme.tabIconSelected,\n        tabBarInactiveTintColor: theme.tabIconDefault,\n        tabBarStyle: {\n          position: \"absolute\",\n          backgroundColor: Platform.select({\n            ios: \"transparent\",\n            android: theme.backgroundRoot,\n          }),\n          borderTopWidth: 0,\n          elevation: 0,\n        },\n        tabBarBackground: () =>\n          Platform.OS === \"ios\" ? (\n            <BlurView\n              intensity={100}\n              tint={isDark ? \"dark\" : \"light\"}\n              style={StyleSheet.absoluteFill}\n            />\n          ) : null,\n        headerShown: false,\n      }}\n    >\n      <Tab.Screen\n        name=\"HomeTab\"\n        component={HomeStackNavigator}\n        options={{\n          title: \"Explore\",\n          tabBarIcon: ({ color, size }) => (\n            <Feather name=\"map-pin\" size={size} color={color} />\n          ),\n        }}\n      />\n      <Tab.Screen\n        name=\"PredictionsTab\"\n        component={PredictionsStackNavigator}\n        options={{\n          title: \"Best Times\",\n          tabBarIcon: ({ color, size }) => (\n            <Feather name=\"trending-up\" size={size} color={color} />\n          ),\n        }}\n      />\n      <Tab.Screen\n        name=\"HistoryTab\"\n        component={HistoryStackNavigator}\n        options={{\n          title: \"Activity\",\n          tabBarIcon: ({ color, size }) => (\n            <Feather name=\"clock\" size={size} color={color} />\n          ),\n        }}\n      />\n      <Tab.Screen\n        name=\"SettingsTab\"\n        component={SettingsStackNavigator}\n        options={{\n          title: \"Settings\",\n          tabBarIcon: ({ color, size }) => (\n            <Feather name=\"settings\" size={size} color={color} />\n          ),\n        }}\n      />\n    </Tab.Navigator>\n  );\n}\n","path":null,"size_bytes":2926,"size_tokens":null},"Mobile-Architect/client/navigation/SettingsStackNavigator.tsx":{"content":"import React from \"react\";\nimport { createNativeStackNavigator } from \"@react-navigation/native-stack\";\nimport SettingsScreen from \"@/screens/SettingsScreen\";\nimport { useScreenOptions } from \"@/hooks/useScreenOptions\";\n\nexport type SettingsStackParamList = {\n  Settings: undefined;\n};\n\nconst Stack = createNativeStackNavigator<SettingsStackParamList>();\n\nexport default function SettingsStackNavigator() {\n  const screenOptions = useScreenOptions();\n\n  return (\n    <Stack.Navigator screenOptions={screenOptions}>\n      <Stack.Screen\n        name=\"Settings\"\n        component={SettingsScreen}\n        options={{\n          headerTitle: \"Settings\",\n        }}\n      />\n    </Stack.Navigator>\n  );\n}\n","path":null,"size_bytes":698,"size_tokens":null},"Mobile-Architect/client/screens/SettingsScreen.tsx":{"content":"import React, { useState, useEffect } from \"react\";\nimport { View, ScrollView, StyleSheet, Alert, Linking } from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useHeaderHeight } from \"@react-navigation/elements\";\nimport { useBottomTabBarHeight } from \"@react-navigation/bottom-tabs\";\nimport Constants from \"expo-constants\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { SettingsRow } from \"@/components/SettingsRow\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing } from \"@/constants/theme\";\nimport { getDeviceId } from \"@/lib/device\";\nimport { clearAllData } from \"@/lib/storage\";\n\nexport default function SettingsScreen() {\n  const insets = useSafeAreaInsets();\n  const headerHeight = useHeaderHeight();\n  const tabBarHeight = useBottomTabBarHeight();\n  const { theme } = useTheme();\n  \n  const [deviceId, setDeviceId] = useState<string>(\"\");\n  const [lowCrowdAlerts, setLowCrowdAlerts] = useState(false);\n  const [savedLocationUpdates, setSavedLocationUpdates] = useState(true);\n\n  useEffect(() => {\n    const loadDeviceId = async () => {\n      const id = await getDeviceId();\n      setDeviceId(id);\n    };\n    loadDeviceId();\n  }, []);\n\n  const handleClearData = () => {\n    Alert.alert(\n      \"Clear All Data\",\n      \"This will remove all saved locations and check-in history. This cannot be undone.\",\n      [\n        { text: \"Cancel\", style: \"cancel\" },\n        {\n          text: \"Clear\",\n          style: \"destructive\",\n          onPress: async () => {\n            await clearAllData();\n            Alert.alert(\"Done\", \"All local data has been cleared.\");\n          },\n        },\n      ]\n    );\n  };\n\n  const handlePrivacyPress = () => {\n    Alert.alert(\n      \"Privacy\",\n      \"QueueSense collects anonymous check-in data to help predict wait times. We never collect personal information, and your device ID is stored locally and used only to prevent duplicate check-ins.\"\n    );\n  };\n\n  const appVersion = Constants.expoConfig?.version || \"1.0.0\";\n  const truncatedDeviceId = deviceId ? `${deviceId.slice(0, 8)}...` : \"Loading...\";\n\n  return (\n    <ScrollView\n      style={[styles.container, { backgroundColor: theme.backgroundRoot }]}\n      contentContainerStyle={{\n        paddingTop: headerHeight + Spacing.xl,\n        paddingBottom: tabBarHeight + Spacing[\"3xl\"],\n        paddingHorizontal: Spacing.lg,\n      }}\n    >\n      <View style={styles.section}>\n        <ThemedText style={[styles.sectionTitle, { color: theme.textSecondary }]}>\n          NOTIFICATIONS\n        </ThemedText>\n        <SettingsRow\n          icon=\"bell\"\n          title=\"Low Crowd Alerts\"\n          subtitle=\"Get notified when wait times are short\"\n          isSwitch\n          switchValue={lowCrowdAlerts}\n          onSwitchChange={setLowCrowdAlerts}\n        />\n        <SettingsRow\n          icon=\"heart\"\n          title=\"Saved Location Updates\"\n          subtitle=\"Updates for your favorite places\"\n          isSwitch\n          switchValue={savedLocationUpdates}\n          onSwitchChange={setSavedLocationUpdates}\n        />\n      </View>\n\n      <View style={styles.section}>\n        <ThemedText style={[styles.sectionTitle, { color: theme.textSecondary }]}>\n          PRIVACY\n        </ThemedText>\n        <SettingsRow\n          icon=\"smartphone\"\n          title=\"Device ID\"\n          value={truncatedDeviceId}\n          showChevron={false}\n        />\n        <SettingsRow\n          icon=\"shield\"\n          title=\"How We Protect Your Privacy\"\n          onPress={handlePrivacyPress}\n        />\n        <SettingsRow\n          icon=\"trash-2\"\n          title=\"Clear All Data\"\n          subtitle=\"Remove saved locations and history\"\n          onPress={handleClearData}\n        />\n      </View>\n\n      <View style={styles.section}>\n        <ThemedText style={[styles.sectionTitle, { color: theme.textSecondary }]}>\n          ABOUT\n        </ThemedText>\n        <SettingsRow\n          icon=\"info\"\n          title=\"Version\"\n          value={appVersion}\n          showChevron={false}\n        />\n        <SettingsRow\n          icon=\"file-text\"\n          title=\"Privacy Policy\"\n          onPress={() => Alert.alert(\"Privacy Policy\", \"Privacy policy would open here.\")}\n        />\n        <SettingsRow\n          icon=\"book\"\n          title=\"Terms of Service\"\n          onPress={() => Alert.alert(\"Terms of Service\", \"Terms of service would open here.\")}\n        />\n        <SettingsRow\n          icon=\"star\"\n          title=\"Rate QueueSense\"\n          onPress={() => Alert.alert(\"Thank You!\", \"Rating feature would be available on the app store.\")}\n        />\n      </View>\n\n      <View style={styles.footer}>\n        <ThemedText style={[styles.footerText, { color: theme.textSecondary }]}>\n          QueueSense helps you save time by predicting wait times at banks, hospitals, and government offices.\n        </ThemedText>\n        <ThemedText style={[styles.footerText, { color: theme.textSecondary, marginTop: Spacing.sm }]}>\n          Made with care for your community.\n        </ThemedText>\n      </View>\n    </ScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  section: {\n    marginBottom: Spacing[\"2xl\"],\n  },\n  sectionTitle: {\n    fontSize: 12,\n    fontWeight: \"600\",\n    letterSpacing: 0.5,\n    marginBottom: Spacing.md,\n    marginLeft: Spacing.xs,\n  },\n  footer: {\n    paddingVertical: Spacing[\"2xl\"],\n    alignItems: \"center\",\n  },\n  footerText: {\n    fontSize: 13,\n    textAlign: \"center\",\n    maxWidth: 280,\n  },\n});\n","path":null,"size_bytes":5524,"size_tokens":null},"Mobile-Architect/client/navigation/PredictionsStackNavigator.tsx":{"content":"import React from \"react\";\nimport { createNativeStackNavigator } from \"@react-navigation/native-stack\";\nimport PredictionsScreen from \"@/screens/PredictionsScreen\";\nimport { useScreenOptions } from \"@/hooks/useScreenOptions\";\n\nexport type PredictionsStackParamList = {\n  Predictions: undefined;\n};\n\nconst Stack = createNativeStackNavigator<PredictionsStackParamList>();\n\nexport default function PredictionsStackNavigator() {\n  const screenOptions = useScreenOptions();\n\n  return (\n    <Stack.Navigator screenOptions={screenOptions}>\n      <Stack.Screen\n        name=\"Predictions\"\n        component={PredictionsScreen}\n        options={{\n          headerTitle: \"Best Times\",\n        }}\n      />\n    </Stack.Navigator>\n  );\n}\n","path":null,"size_bytes":724,"size_tokens":null},"Mobile-Architect/client/screens/CheckinModal.tsx":{"content":"import React, { useState } from \"react\";\nimport { View, StyleSheet, Alert, ActivityIndicator } from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useNavigation, useRoute, RouteProp } from \"@react-navigation/native\";\nimport { useMutation } from \"@tanstack/react-query\";\nimport { Feather } from \"@expo/vector-icons\";\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring, withSequence, withTiming, runOnJS } from \"react-native-reanimated\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { NumberStepper } from \"@/components/NumberStepper\";\nimport { Button } from \"@/components/Button\";\nimport { Card } from \"@/components/Card\";\nimport { KeyboardAwareScrollViewCompat } from \"@/components/KeyboardAwareScrollViewCompat\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\nimport { apiRequest, queryClient } from \"@/lib/query-client\";\nimport { getDeviceId } from \"@/lib/device\";\nimport { addRecentCheckin } from \"@/lib/storage\";\nimport { RootStackParamList } from \"@/navigation/RootStackNavigator\";\n\nconst QUEUE_STAGES = [\n  { value: \"waiting\", label: \"Waiting\" },\n  { value: \"in_service\", label: \"In Service\" },\n  { value: \"completing\", label: \"Completing\" },\n];\n\nexport default function CheckinModal() {\n  const insets = useSafeAreaInsets();\n  const { theme } = useTheme();\n  const navigation = useNavigation();\n  const route = useRoute<RouteProp<RootStackParamList, \"CheckinModal\">>();\n  const { locationId, locationName } = route.params;\n\n  const [peopleAhead, setPeopleAhead] = useState(0);\n  const [queueStage, setQueueStage] = useState(\"waiting\");\n  const [showSuccess, setShowSuccess] = useState(false);\n\n  const successScale = useSharedValue(0);\n  const successOpacity = useSharedValue(0);\n\n  const successAnimatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: successScale.value }],\n    opacity: successOpacity.value,\n  }));\n\n  const checkinMutation = useMutation({\n    mutationFn: async () => {\n      const deviceId = await getDeviceId();\n      const response = await apiRequest(\"POST\", \"/api/checkin\", {\n        locationId,\n        deviceId,\n        peopleAhead,\n        queueStage,\n      });\n      return response.json();\n    },\n    onSuccess: async (data) => {\n      await addRecentCheckin({\n        id: data.id,\n        locationId,\n        locationName,\n        peopleAhead,\n        createdAt: new Date().toISOString(),\n      });\n\n      queryClient.invalidateQueries({ queryKey: [\"/api/locations\", locationId] });\n\n      setShowSuccess(true);\n      successScale.value = withSequence(\n        withSpring(1.2, { damping: 10, stiffness: 100 }),\n        withSpring(1, { damping: 15, stiffness: 100 })\n      );\n      successOpacity.value = withTiming(1, { duration: 200 });\n\n      setTimeout(() => {\n        navigation.goBack();\n      }, 1500);\n    },\n    onError: (error: Error) => {\n      const message = error.message.includes(\"429\")\n        ? \"Please wait 15 minutes between check-ins at the same location.\"\n        : \"Failed to submit check-in. Please try again.\";\n      Alert.alert(\"Error\", message);\n    },\n  });\n\n  const handleSubmit = () => {\n    checkinMutation.mutate();\n  };\n\n  if (showSuccess) {\n    return (\n      <ThemedView style={[styles.successContainer, { paddingBottom: insets.bottom + Spacing.xl }]}>\n        <Animated.View style={[styles.successContent, successAnimatedStyle]}>\n          <View style={[styles.successIcon, { backgroundColor: theme.success }]}>\n            <Feather name=\"check\" size={48} color=\"#FFFFFF\" />\n          </View>\n          <ThemedText type=\"h3\" style={styles.successTitle}>\n            Thank You!\n          </ThemedText>\n          <ThemedText style={[styles.successMessage, { color: theme.textSecondary }]}>\n            Your check-in helps others save time\n          </ThemedText>\n        </Animated.View>\n      </ThemedView>\n    );\n  }\n\n  return (\n    <KeyboardAwareScrollViewCompat\n      style={[styles.container, { backgroundColor: theme.backgroundRoot }]}\n      contentContainerStyle={{\n        paddingTop: Spacing.xl,\n        paddingBottom: insets.bottom + Spacing[\"3xl\"],\n        paddingHorizontal: Spacing.lg,\n        flexGrow: 1,\n      }}\n    >\n      <Card elevation={1} style={styles.locationCard}>\n        <View style={styles.locationRow}>\n          <Feather name=\"map-pin\" size={20} color={theme.primary} />\n          <View style={styles.locationInfo}>\n            <ThemedText style={styles.locationLabel}>Checking in at</ThemedText>\n            <ThemedText style={styles.locationName}>{locationName}</ThemedText>\n          </View>\n        </View>\n      </Card>\n\n      <View style={styles.formSection}>\n        <ThemedText type=\"h4\" style={styles.questionLabel}>\n          How many people are ahead of you?\n        </ThemedText>\n        <View style={styles.stepperContainer}>\n          <NumberStepper\n            value={peopleAhead}\n            onChange={setPeopleAhead}\n            min={0}\n            max={200}\n          />\n        </View>\n      </View>\n\n      <View style={styles.formSection}>\n        <ThemedText type=\"h4\" style={styles.questionLabel}>\n          Queue stage (optional)\n        </ThemedText>\n        <View style={styles.stagesContainer}>\n          {QUEUE_STAGES.map((stage) => (\n            <Card\n              key={stage.value}\n              elevation={queueStage === stage.value ? 2 : 1}\n              style={[\n                styles.stageCard,\n                queueStage === stage.value && { borderColor: theme.primary, borderWidth: 2 },\n              ]}\n              onPress={() => setQueueStage(stage.value)}\n            >\n              <ThemedText\n                style={[\n                  styles.stageLabel,\n                  queueStage === stage.value && { color: theme.primary, fontWeight: \"600\" },\n                ]}\n              >\n                {stage.label}\n              </ThemedText>\n            </Card>\n          ))}\n        </View>\n      </View>\n\n      <View style={styles.submitContainer}>\n        <Button\n          onPress={handleSubmit}\n          disabled={checkinMutation.isPending}\n          style={styles.submitButton}\n        >\n          {checkinMutation.isPending ? (\n            <ActivityIndicator color=\"#FFFFFF\" />\n          ) : (\n            \"Submit Check-in\"\n          )}\n        </Button>\n        <ThemedText style={[styles.disclaimer, { color: theme.textSecondary }]}>\n          Your check-in is anonymous and helps improve predictions for everyone.\n        </ThemedText>\n      </View>\n    </KeyboardAwareScrollViewCompat>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  successContainer: {\n    flex: 1,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  successContent: {\n    alignItems: \"center\",\n  },\n  successIcon: {\n    width: 96,\n    height: 96,\n    borderRadius: 48,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    marginBottom: Spacing.xl,\n  },\n  successTitle: {\n    marginBottom: Spacing.sm,\n  },\n  successMessage: {\n    fontSize: 16,\n    textAlign: \"center\",\n  },\n  locationCard: {\n    marginBottom: Spacing[\"2xl\"],\n  },\n  locationRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.md,\n  },\n  locationInfo: {\n    flex: 1,\n  },\n  locationLabel: {\n    fontSize: 12,\n    opacity: 0.7,\n  },\n  locationName: {\n    fontSize: 16,\n    fontWeight: \"600\",\n    marginTop: 2,\n  },\n  formSection: {\n    marginBottom: Spacing[\"2xl\"],\n  },\n  questionLabel: {\n    marginBottom: Spacing.lg,\n  },\n  stepperContainer: {\n    alignItems: \"center\",\n    paddingVertical: Spacing.lg,\n  },\n  stagesContainer: {\n    flexDirection: \"row\",\n    gap: Spacing.md,\n  },\n  stageCard: {\n    flex: 1,\n    alignItems: \"center\",\n    paddingVertical: Spacing.lg,\n  },\n  stageLabel: {\n    fontSize: 14,\n  },\n  submitContainer: {\n    marginTop: \"auto\",\n    paddingTop: Spacing.xl,\n  },\n  submitButton: {\n    marginBottom: Spacing.md,\n  },\n  disclaimer: {\n    fontSize: 12,\n    textAlign: \"center\",\n  },\n});\n","path":null,"size_bytes":8070,"size_tokens":null},"Mobile-Architect/client/screens/QueueStatusScreen.tsx":{"content":"import React, { useState, useEffect, useCallback } from \"react\";\nimport { View, ScrollView, RefreshControl, StyleSheet, Pressable } from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useHeaderHeight } from \"@react-navigation/elements\";\nimport { useNavigation, useRoute, RouteProp, useFocusEffect } from \"@react-navigation/native\";\nimport { NativeStackNavigationProp } from \"@react-navigation/native-stack\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { Feather } from \"@expo/vector-icons\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { WaitTimeIndicator } from \"@/components/WaitTimeIndicator\";\nimport { TrendIndicator } from \"@/components/TrendIndicator\";\nimport { Card } from \"@/components/Card\";\nimport { Button } from \"@/components/Button\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\nimport { HomeStackParamList } from \"@/navigation/HomeStackNavigator\";\nimport { RootStackParamList } from \"@/navigation/RootStackNavigator\";\nimport { isLocationSaved, saveLocation, removeSavedLocation } from \"@/lib/storage\";\n\ntype QueueStatusData = {\n  location: {\n    id: string;\n    name: string;\n    address: string;\n    typeId: string;\n  };\n  estimatedWaitTime: number;\n  confidence: number;\n  trend: \"increasing\" | \"stable\" | \"decreasing\";\n  currentQueueSize: number;\n  lastUpdated: string;\n};\n\nexport default function QueueStatusScreen() {\n  const insets = useSafeAreaInsets();\n  const headerHeight = useHeaderHeight();\n  const { theme } = useTheme();\n  const navigation = useNavigation<NativeStackNavigationProp<HomeStackParamList & RootStackParamList>>();\n  const route = useRoute<RouteProp<HomeStackParamList, \"QueueStatus\">>();\n  const { locationId, locationName } = route.params;\n\n  const [refreshing, setRefreshing] = useState(false);\n  const [isSaved, setIsSaved] = useState(false);\n\n  const { data, isLoading, refetch } = useQuery<QueueStatusData>({\n    queryKey: [\"/api/locations\", locationId, \"queue-status\"],\n    refetchInterval: 30000,\n  });\n\n  useEffect(() => {\n    const checkSaved = async () => {\n      const saved = await isLocationSaved(locationId);\n      setIsSaved(saved);\n    };\n    checkSaved();\n  }, [locationId]);\n\n  useFocusEffect(\n    useCallback(() => {\n      refetch();\n    }, [refetch])\n  );\n\n  const handleRefresh = async () => {\n    setRefreshing(true);\n    await refetch();\n    setRefreshing(false);\n  };\n\n  const handleToggleSave = async () => {\n    if (isSaved) {\n      await removeSavedLocation(locationId);\n      setIsSaved(false);\n    } else if (data?.location) {\n      await saveLocation({\n        id: locationId,\n        name: data.location.name,\n        address: data.location.address,\n        typeId: data.location.typeId,\n        savedAt: new Date().toISOString(),\n      });\n      setIsSaved(true);\n    }\n  };\n\n  const handleCheckin = () => {\n    navigation.navigate(\"CheckinModal\", { locationId, locationName });\n  };\n\n  useEffect(() => {\n    navigation.setOptions({\n      headerRight: () => (\n        <Pressable onPress={handleToggleSave} style={styles.headerButton}>\n          <Feather name={isSaved ? \"heart\" : \"heart\"} size={22} color={isSaved ? theme.error : theme.text} />\n        </Pressable>\n      ),\n    });\n  }, [navigation, isSaved, theme]);\n\n  const formatTime = (isoString: string) => {\n    const date = new Date(isoString);\n    return date.toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" });\n  };\n\n  return (\n    <ScrollView\n      style={[styles.container, { backgroundColor: theme.backgroundRoot }]}\n      contentContainerStyle={{\n        paddingTop: headerHeight + Spacing.xl,\n        paddingBottom: insets.bottom + Spacing[\"3xl\"],\n        paddingHorizontal: Spacing.lg,\n      }}\n      refreshControl={\n        <RefreshControl refreshing={refreshing} onRefresh={handleRefresh} tintColor={theme.primary} />\n      }\n    >\n      <View style={styles.heroSection}>\n        <WaitTimeIndicator\n          minutes={data?.estimatedWaitTime || 0}\n          confidence={data?.confidence || 0}\n        />\n        <View style={styles.trendContainer}>\n          <TrendIndicator trend={data?.trend || \"stable\"} />\n        </View>\n      </View>\n\n      <Card elevation={1} style={styles.infoCard}>\n        <View style={styles.infoRow}>\n          <View style={styles.infoItem}>\n            <Feather name=\"users\" size={20} color={theme.primary} />\n            <View style={styles.infoText}>\n              <ThemedText style={styles.infoValue}>\n                {data?.currentQueueSize || 0}\n              </ThemedText>\n              <ThemedText style={[styles.infoLabel, { color: theme.textSecondary }]}>\n                People in queue\n              </ThemedText>\n            </View>\n          </View>\n          <View style={[styles.divider, { backgroundColor: theme.border }]} />\n          <View style={styles.infoItem}>\n            <Feather name=\"refresh-cw\" size={20} color={theme.primary} />\n            <View style={styles.infoText}>\n              <ThemedText style={styles.infoValue}>\n                {data?.lastUpdated ? formatTime(data.lastUpdated) : \"--:--\"}\n              </ThemedText>\n              <ThemedText style={[styles.infoLabel, { color: theme.textSecondary }]}>\n                Last updated\n              </ThemedText>\n            </View>\n          </View>\n        </View>\n      </Card>\n\n      <Card elevation={1} style={styles.checkinCard}>\n        <View style={styles.checkinContent}>\n          <View style={styles.checkinInfo}>\n            <Feather name=\"check-circle\" size={24} color={theme.success} />\n            <View style={styles.checkinText}>\n              <ThemedText style={styles.checkinTitle}>Help others</ThemedText>\n              <ThemedText style={[styles.checkinDesc, { color: theme.textSecondary }]}>\n                Share your queue position to improve predictions\n              </ThemedText>\n            </View>\n          </View>\n          <Button onPress={handleCheckin} style={styles.checkinButton}>\n            Check In\n          </Button>\n        </View>\n      </Card>\n\n      {data?.location ? (\n        <Card elevation={1} style={styles.locationCard}>\n          <View style={styles.locationHeader}>\n            <Feather name=\"map-pin\" size={20} color={theme.primary} />\n            <ThemedText style={styles.locationTitle}>Location Details</ThemedText>\n          </View>\n          <ThemedText style={[styles.locationAddress, { color: theme.textSecondary }]}>\n            {data.location.address}\n          </ThemedText>\n        </Card>\n      ) : null}\n    </ScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  heroSection: {\n    alignItems: \"center\",\n    paddingVertical: Spacing[\"2xl\"],\n  },\n  trendContainer: {\n    marginTop: Spacing.lg,\n  },\n  infoCard: {\n    marginBottom: Spacing.lg,\n  },\n  infoRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n  },\n  infoItem: {\n    flex: 1,\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.md,\n  },\n  infoText: {},\n  infoValue: {\n    fontSize: 18,\n    fontWeight: \"600\",\n  },\n  infoLabel: {\n    fontSize: 12,\n    marginTop: 2,\n  },\n  divider: {\n    width: 1,\n    height: 40,\n    marginHorizontal: Spacing.lg,\n  },\n  checkinCard: {\n    marginBottom: Spacing.lg,\n  },\n  checkinContent: {\n    gap: Spacing.lg,\n  },\n  checkinInfo: {\n    flexDirection: \"row\",\n    alignItems: \"flex-start\",\n    gap: Spacing.md,\n  },\n  checkinText: {\n    flex: 1,\n  },\n  checkinTitle: {\n    fontSize: 16,\n    fontWeight: \"600\",\n  },\n  checkinDesc: {\n    fontSize: 14,\n    marginTop: 4,\n  },\n  checkinButton: {\n    marginTop: Spacing.sm,\n  },\n  locationCard: {\n    marginBottom: Spacing.lg,\n  },\n  locationHeader: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.sm,\n    marginBottom: Spacing.sm,\n  },\n  locationTitle: {\n    fontSize: 16,\n    fontWeight: \"600\",\n  },\n  locationAddress: {\n    fontSize: 14,\n  },\n  headerButton: {\n    padding: Spacing.sm,\n  },\n});\n","path":null,"size_bytes":8049,"size_tokens":null},"Mobile-Architect/client/components/CrowdIndicator.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet } from \"react-native\";\nimport { useTheme } from \"@/hooks/useTheme\";\n\ninterface CrowdIndicatorProps {\n  queueSize: number;\n  size?: number;\n}\n\nfunction getCrowdColor(queueSize: number, theme: any): string {\n  if (queueSize < 5) return theme.success;\n  if (queueSize < 15) return theme.warning;\n  return theme.error;\n}\n\nexport function CrowdIndicator({ queueSize, size = 12 }: CrowdIndicatorProps) {\n  const { theme } = useTheme();\n  const color = getCrowdColor(queueSize, theme);\n\n  return (\n    <View style={[styles.dot, { width: size, height: size, borderRadius: size / 2, backgroundColor: color }]} />\n  );\n}\n\nconst styles = StyleSheet.create({\n  dot: {},\n});\n","path":null,"size_bytes":715,"size_tokens":null},"Mobile-Architect/client/components/HeatmapGrid.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet, ScrollView, Pressable } from \"react-native\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\n\ninterface TimeSlotData {\n  dayOfWeek: number;\n  hour: number;\n  averageWaitTime: number;\n  sampleCount: number;\n}\n\ninterface HeatmapGridProps {\n  data: TimeSlotData[];\n  onCellPress?: (dayOfWeek: number, hour: number, waitTime: number) => void;\n}\n\nconst DAYS = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\nconst HOURS = Array.from({ length: 12 }, (_, i) => i + 8);\n\nfunction getHeatColor(waitTime: number, maxWait: number, theme: any): string {\n  if (waitTime === 0) return theme.backgroundDefault;\n  const intensity = Math.min(waitTime / Math.max(maxWait, 30), 1);\n  if (intensity < 0.33) return theme.success + \"60\";\n  if (intensity < 0.66) return theme.warning + \"80\";\n  return theme.error + \"A0\";\n}\n\nexport function HeatmapGrid({ data, onCellPress }: HeatmapGridProps) {\n  const { theme } = useTheme();\n\n  const dataMap = new Map<string, TimeSlotData>();\n  let maxWait = 0;\n  data.forEach((slot) => {\n    const key = `${slot.dayOfWeek}-${slot.hour}`;\n    dataMap.set(key, slot);\n    if (slot.averageWaitTime > maxWait) maxWait = slot.averageWaitTime;\n  });\n\n  return (\n    <ScrollView horizontal showsHorizontalScrollIndicator={false}>\n      <View style={styles.container}>\n        <View style={styles.headerRow}>\n          <View style={styles.cornerCell} />\n          {HOURS.map((hour) => (\n            <View key={hour} style={styles.hourCell}>\n              <ThemedText style={[styles.hourLabel, { color: theme.textSecondary }]}>\n                {hour > 12 ? hour - 12 : hour}{hour >= 12 ? \"p\" : \"a\"}\n              </ThemedText>\n            </View>\n          ))}\n        </View>\n        {DAYS.map((day, dayIndex) => (\n          <View key={day} style={styles.row}>\n            <View style={styles.dayCell}>\n              <ThemedText style={[styles.dayLabel, { color: theme.textSecondary }]}>\n                {day}\n              </ThemedText>\n            </View>\n            {HOURS.map((hour) => {\n              const slot = dataMap.get(`${dayIndex}-${hour}`);\n              const waitTime = slot?.averageWaitTime || 0;\n              return (\n                <Pressable\n                  key={hour}\n                  onPress={() => onCellPress?.(dayIndex, hour, Math.round(waitTime))}\n                  style={[\n                    styles.cell,\n                    { backgroundColor: getHeatColor(waitTime, maxWait, theme) },\n                  ]}\n                />\n              );\n            })}\n          </View>\n        ))}\n      </View>\n    </ScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    paddingVertical: Spacing.md,\n  },\n  headerRow: {\n    flexDirection: \"row\",\n    marginBottom: Spacing.xs,\n  },\n  row: {\n    flexDirection: \"row\",\n    marginBottom: Spacing.xs,\n  },\n  cornerCell: {\n    width: 40,\n    height: 24,\n  },\n  hourCell: {\n    width: 32,\n    height: 24,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  hourLabel: {\n    fontSize: 10,\n  },\n  dayCell: {\n    width: 40,\n    height: 28,\n    alignItems: \"flex-start\",\n    justifyContent: \"center\",\n  },\n  dayLabel: {\n    fontSize: 12,\n  },\n  cell: {\n    width: 28,\n    height: 28,\n    marginHorizontal: 2,\n    borderRadius: BorderRadius.xs,\n  },\n});\n","path":null,"size_bytes":3423,"size_tokens":null},"Mobile-Architect/server/storage.ts":{"content":"import { \n  locationTypes, locations, checkins, timeSlots, predictions,\n  type LocationType, type InsertLocationType,\n  type Location, type InsertLocation,\n  type Checkin, type InsertCheckin,\n  type TimeSlot, type InsertTimeSlot,\n  type Prediction, type InsertPrediction\n} from \"@shared/schema\";\nimport { db } from \"./db\";\nimport { eq, desc, and, gte, sql } from \"drizzle-orm\";\n\nexport interface IStorage {\n  getLocationTypes(): Promise<LocationType[]>;\n  getLocationType(id: string): Promise<LocationType | undefined>;\n  createLocationType(data: InsertLocationType): Promise<LocationType>;\n  \n  getLocations(): Promise<Location[]>;\n  getLocationsByType(typeId: string): Promise<Location[]>;\n  getLocation(id: string): Promise<Location | undefined>;\n  createLocation(data: InsertLocation): Promise<Location>;\n  \n  getCheckins(locationId: string, since?: Date): Promise<Checkin[]>;\n  getRecentCheckins(locationId: string, minutes: number): Promise<Checkin[]>;\n  createCheckin(data: InsertCheckin): Promise<Checkin>;\n  getDeviceCheckins(deviceId: string): Promise<Checkin[]>;\n  canDeviceCheckin(deviceId: string, locationId: string): Promise<boolean>;\n  \n  getTimeSlots(locationId: string): Promise<TimeSlot[]>;\n  getTimeSlot(locationId: string, dayOfWeek: number, hour: number): Promise<TimeSlot | undefined>;\n  upsertTimeSlot(data: InsertTimeSlot): Promise<TimeSlot>;\n  \n  getPrediction(locationId: string): Promise<Prediction | undefined>;\n  createPrediction(data: InsertPrediction): Promise<Prediction>;\n}\n\nexport class DatabaseStorage implements IStorage {\n  async getLocationTypes(): Promise<LocationType[]> {\n    return db.select().from(locationTypes);\n  }\n\n  async getLocationType(id: string): Promise<LocationType | undefined> {\n    const [type] = await db.select().from(locationTypes).where(eq(locationTypes.id, id));\n    return type || undefined;\n  }\n\n  async createLocationType(data: InsertLocationType): Promise<LocationType> {\n    const [type] = await db.insert(locationTypes).values(data).returning();\n    return type;\n  }\n\n  async getLocations(): Promise<Location[]> {\n    return db.select().from(locations).where(eq(locations.isActive, true));\n  }\n\n  async getLocationsByType(typeId: string): Promise<Location[]> {\n    return db.select().from(locations).where(\n      and(eq(locations.typeId, typeId), eq(locations.isActive, true))\n    );\n  }\n\n  async getLocation(id: string): Promise<Location | undefined> {\n    const [location] = await db.select().from(locations).where(eq(locations.id, id));\n    return location || undefined;\n  }\n\n  async createLocation(data: InsertLocation): Promise<Location> {\n    const [location] = await db.insert(locations).values(data).returning();\n    return location;\n  }\n\n  async getCheckins(locationId: string, since?: Date): Promise<Checkin[]> {\n    if (since) {\n      return db.select().from(checkins).where(\n        and(eq(checkins.locationId, locationId), gte(checkins.createdAt, since))\n      ).orderBy(desc(checkins.createdAt));\n    }\n    return db.select().from(checkins).where(eq(checkins.locationId, locationId)).orderBy(desc(checkins.createdAt));\n  }\n\n  async getRecentCheckins(locationId: string, minutes: number): Promise<Checkin[]> {\n    const since = new Date(Date.now() - minutes * 60 * 1000);\n    return this.getCheckins(locationId, since);\n  }\n\n  async createCheckin(data: InsertCheckin): Promise<Checkin> {\n    const [checkin] = await db.insert(checkins).values({\n      ...data,\n      confidence: 1.0,\n    }).returning();\n    return checkin;\n  }\n\n  async getDeviceCheckins(deviceId: string): Promise<Checkin[]> {\n    return db.select().from(checkins).where(eq(checkins.deviceId, deviceId)).orderBy(desc(checkins.createdAt)).limit(50);\n  }\n\n  async canDeviceCheckin(deviceId: string, locationId: string): Promise<boolean> {\n    const fifteenMinutesAgo = new Date(Date.now() - 15 * 60 * 1000);\n    const recentCheckins = await db.select().from(checkins).where(\n      and(\n        eq(checkins.deviceId, deviceId),\n        eq(checkins.locationId, locationId),\n        gte(checkins.createdAt, fifteenMinutesAgo)\n      )\n    );\n    return recentCheckins.length === 0;\n  }\n\n  async getTimeSlots(locationId: string): Promise<TimeSlot[]> {\n    return db.select().from(timeSlots).where(eq(timeSlots.locationId, locationId));\n  }\n\n  async getTimeSlot(locationId: string, dayOfWeek: number, hour: number): Promise<TimeSlot | undefined> {\n    const [slot] = await db.select().from(timeSlots).where(\n      and(\n        eq(timeSlots.locationId, locationId),\n        eq(timeSlots.dayOfWeek, dayOfWeek),\n        eq(timeSlots.hour, hour)\n      )\n    );\n    return slot || undefined;\n  }\n\n  async upsertTimeSlot(data: InsertTimeSlot): Promise<TimeSlot> {\n    const existing = await this.getTimeSlot(data.locationId, data.dayOfWeek, data.hour);\n    if (existing) {\n      const [updated] = await db.update(timeSlots)\n        .set({\n          averageWaitTime: data.averageWaitTime,\n          averagePeopleCount: data.averagePeopleCount,\n          sampleCount: data.sampleCount,\n          updatedAt: new Date(),\n        })\n        .where(eq(timeSlots.id, existing.id))\n        .returning();\n      return updated;\n    }\n    const [slot] = await db.insert(timeSlots).values(data).returning();\n    return slot;\n  }\n\n  async getPrediction(locationId: string): Promise<Prediction | undefined> {\n    const [prediction] = await db.select().from(predictions)\n      .where(eq(predictions.locationId, locationId))\n      .orderBy(desc(predictions.createdAt))\n      .limit(1);\n    return prediction || undefined;\n  }\n\n  async createPrediction(data: InsertPrediction): Promise<Prediction> {\n    const [prediction] = await db.insert(predictions).values(data).returning();\n    return prediction;\n  }\n}\n\nexport const storage = new DatabaseStorage();\n","path":null,"size_bytes":5774,"size_tokens":null},"Mobile-Architect/server/index.ts":{"content":"import express from \"express\";\nimport type { Request, Response, NextFunction } from \"express\";\nimport { registerRoutes } from \"./routes\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\n\nconst app = express();\nconst log = console.log;\n\ndeclare module \"http\" {\n  interface IncomingMessage {\n    rawBody: unknown;\n  }\n}\n\nfunction setupCors(app: express.Application) {\n  app.use((req, res, next) => {\n    const origins = new Set<string>();\n\n    if (process.env.REPLIT_DEV_DOMAIN) {\n      origins.add(`https://${process.env.REPLIT_DEV_DOMAIN}`);\n    }\n\n    if (process.env.REPLIT_DOMAINS) {\n      process.env.REPLIT_DOMAINS.split(\",\").forEach((d) => {\n        origins.add(`https://${d.trim()}`);\n      });\n    }\n\n    const origin = req.header(\"origin\");\n\n    if (origin && origins.has(origin)) {\n      res.header(\"Access-Control-Allow-Origin\", origin);\n      res.header(\n        \"Access-Control-Allow-Methods\",\n        \"GET, POST, PUT, DELETE, OPTIONS\",\n      );\n      res.header(\"Access-Control-Allow-Headers\", \"Content-Type\");\n      res.header(\"Access-Control-Allow-Credentials\", \"true\");\n    }\n\n    if (req.method === \"OPTIONS\") {\n      return res.sendStatus(200);\n    }\n\n    next();\n  });\n}\n\nfunction setupBodyParsing(app: express.Application) {\n  app.use(\n    express.json({\n      verify: (req, _res, buf) => {\n        req.rawBody = buf;\n      },\n    }),\n  );\n\n  app.use(express.urlencoded({ extended: false }));\n}\n\nfunction setupRequestLogging(app: express.Application) {\n  app.use((req, res, next) => {\n    const start = Date.now();\n    const path = req.path;\n    let capturedJsonResponse: Record<string, unknown> | undefined = undefined;\n\n    const originalResJson = res.json;\n    res.json = function (bodyJson, ...args) {\n      capturedJsonResponse = bodyJson;\n      return originalResJson.apply(res, [bodyJson, ...args]);\n    };\n\n    res.on(\"finish\", () => {\n      if (!path.startsWith(\"/api\")) return;\n\n      const duration = Date.now() - start;\n\n      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;\n      if (capturedJsonResponse) {\n        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;\n      }\n\n      if (logLine.length > 80) {\n        logLine = logLine.slice(0, 79) + \"…\";\n      }\n\n      log(logLine);\n    });\n\n    next();\n  });\n}\n\nfunction getAppName(): string {\n  try {\n    const appJsonPath = path.resolve(process.cwd(), \"app.json\");\n    const appJsonContent = fs.readFileSync(appJsonPath, \"utf-8\");\n    const appJson = JSON.parse(appJsonContent);\n    return appJson.expo?.name || \"App Landing Page\";\n  } catch {\n    return \"App Landing Page\";\n  }\n}\n\nfunction serveExpoManifest(platform: string, res: Response) {\n  const manifestPath = path.resolve(\n    process.cwd(),\n    \"static-build\",\n    platform,\n    \"manifest.json\",\n  );\n\n  if (!fs.existsSync(manifestPath)) {\n    return res\n      .status(404)\n      .json({ error: `Manifest not found for platform: ${platform}` });\n  }\n\n  res.setHeader(\"expo-protocol-version\", \"1\");\n  res.setHeader(\"expo-sfv-version\", \"0\");\n  res.setHeader(\"content-type\", \"application/json\");\n\n  const manifest = fs.readFileSync(manifestPath, \"utf-8\");\n  res.send(manifest);\n}\n\nfunction serveLandingPage({\n  req,\n  res,\n  landingPageTemplate,\n  appName,\n}: {\n  req: Request;\n  res: Response;\n  landingPageTemplate: string;\n  appName: string;\n}) {\n  const forwardedProto = req.header(\"x-forwarded-proto\");\n  const protocol = forwardedProto || req.protocol || \"https\";\n  const forwardedHost = req.header(\"x-forwarded-host\");\n  const host = forwardedHost || req.get(\"host\");\n  const baseUrl = `${protocol}://${host}`;\n  const expsUrl = `${host}`;\n\n  log(`baseUrl`, baseUrl);\n  log(`expsUrl`, expsUrl);\n\n  const html = landingPageTemplate\n    .replace(/BASE_URL_PLACEHOLDER/g, baseUrl)\n    .replace(/EXPS_URL_PLACEHOLDER/g, expsUrl)\n    .replace(/APP_NAME_PLACEHOLDER/g, appName);\n\n  res.setHeader(\"Content-Type\", \"text/html; charset=utf-8\");\n  res.status(200).send(html);\n}\n\nfunction configureExpoAndLanding(app: express.Application) {\n  const templatePath = path.resolve(\n    process.cwd(),\n    \"server\",\n    \"templates\",\n    \"landing-page.html\",\n  );\n  const landingPageTemplate = fs.readFileSync(templatePath, \"utf-8\");\n  const appName = getAppName();\n\n  log(\"Serving static Expo files with dynamic manifest routing\");\n\n  app.use((req: Request, res: Response, next: NextFunction) => {\n    if (req.path.startsWith(\"/api\")) {\n      return next();\n    }\n\n    if (req.path !== \"/\" && req.path !== \"/manifest\") {\n      return next();\n    }\n\n    const platform = req.header(\"expo-platform\");\n    if (platform && (platform === \"ios\" || platform === \"android\")) {\n      return serveExpoManifest(platform, res);\n    }\n\n    if (req.path === \"/\") {\n      return serveLandingPage({\n        req,\n        res,\n        landingPageTemplate,\n        appName,\n      });\n    }\n\n    next();\n  });\n\n  app.use(\"/assets\", express.static(path.resolve(process.cwd(), \"assets\")));\n  app.use(express.static(path.resolve(process.cwd(), \"static-build\")));\n\n  log(\"Expo routing: Checking expo-platform header on / and /manifest\");\n}\n\nfunction setupErrorHandler(app: express.Application) {\n  app.use((err: unknown, _req: Request, res: Response, _next: NextFunction) => {\n    const error = err as {\n      status?: number;\n      statusCode?: number;\n      message?: string;\n    };\n\n    const status = error.status || error.statusCode || 500;\n    const message = error.message || \"Internal Server Error\";\n\n    res.status(status).json({ message });\n\n    throw err;\n  });\n}\n\n(async () => {\n  setupCors(app);\n  setupBodyParsing(app);\n  setupRequestLogging(app);\n\n  configureExpoAndLanding(app);\n\n  const server = await registerRoutes(app);\n\n  setupErrorHandler(app);\n\n  const port = parseInt(process.env.PORT || \"5000\", 10);\n  server.listen(\n    {\n      port,\n      host: \"0.0.0.0\",\n      reusePort: true,\n    },\n    () => {\n      log(`express server serving on port ${port}`);\n    },\n  );\n})();\n","path":null,"size_bytes":5949,"size_tokens":null},"Mobile-Architect/client/components/ThemedView.tsx":{"content":"import { View, type ViewProps } from \"react-native\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\n\nexport type ThemedViewProps = ViewProps & {\n  lightColor?: string;\n  darkColor?: string;\n};\n\nexport function ThemedView({\n  style,\n  lightColor,\n  darkColor,\n  ...otherProps\n}: ThemedViewProps) {\n  const { theme, isDark } = useTheme();\n\n  const backgroundColor =\n    isDark && darkColor\n      ? darkColor\n      : !isDark && lightColor\n        ? lightColor\n        : theme.backgroundRoot;\n\n  return <View style={[{ backgroundColor }, style]} {...otherProps} />;\n}\n","path":null,"size_bytes":563,"size_tokens":null},"Mobile-Architect/client/constants/theme.ts":{"content":"import { Platform } from \"react-native\";\n\nconst tintColorLight = \"#1976D2\";\nconst tintColorDark = \"#42A5F5\";\n\nexport const Colors = {\n  light: {\n    text: \"#212121\",\n    textSecondary: \"#757575\",\n    textDisabled: \"#BDBDBD\",\n    buttonText: \"#FFFFFF\",\n    tabIconDefault: \"#687076\",\n    tabIconSelected: tintColorLight,\n    link: \"#1976D2\",\n    primary: \"#1976D2\",\n    secondary: \"#388E3C\",\n    success: \"#4CAF50\",\n    warning: \"#FF9800\",\n    error: \"#F44336\",\n    info: \"#2196F3\",\n    backgroundRoot: \"#FFFFFF\",\n    backgroundDefault: \"#F5F5F5\",\n    backgroundSecondary: \"#EEEEEE\",\n    backgroundTertiary: \"#E0E0E0\",\n    surface: \"#FFFFFF\",\n    border: \"#E0E0E0\",\n  },\n  dark: {\n    text: \"#ECEDEE\",\n    textSecondary: \"#9BA1A6\",\n    textDisabled: \"#687076\",\n    buttonText: \"#FFFFFF\",\n    tabIconDefault: \"#9BA1A6\",\n    tabIconSelected: tintColorDark,\n    link: \"#42A5F5\",\n    primary: \"#42A5F5\",\n    secondary: \"#66BB6A\",\n    success: \"#66BB6A\",\n    warning: \"#FFA726\",\n    error: \"#EF5350\",\n    info: \"#42A5F5\",\n    backgroundRoot: \"#1F2123\",\n    backgroundDefault: \"#2A2C2E\",\n    backgroundSecondary: \"#353739\",\n    backgroundTertiary: \"#404244\",\n    surface: \"#2A2C2E\",\n    border: \"#404244\",\n  },\n};\n\nexport const Spacing = {\n  xs: 4,\n  sm: 8,\n  md: 12,\n  lg: 16,\n  xl: 20,\n  \"2xl\": 24,\n  \"3xl\": 32,\n  \"4xl\": 40,\n  \"5xl\": 48,\n  inputHeight: 48,\n  buttonHeight: 52,\n};\n\nexport const BorderRadius = {\n  xs: 8,\n  sm: 12,\n  md: 18,\n  lg: 24,\n  xl: 30,\n  \"2xl\": 40,\n  \"3xl\": 50,\n  full: 9999,\n};\n\nexport const Typography = {\n  h1: {\n    fontSize: 32,\n    fontWeight: \"700\" as const,\n  },\n  h2: {\n    fontSize: 28,\n    fontWeight: \"700\" as const,\n  },\n  h3: {\n    fontSize: 24,\n    fontWeight: \"600\" as const,\n  },\n  h4: {\n    fontSize: 20,\n    fontWeight: \"600\" as const,\n  },\n  body: {\n    fontSize: 16,\n    fontWeight: \"400\" as const,\n  },\n  small: {\n    fontSize: 14,\n    fontWeight: \"400\" as const,\n  },\n  caption: {\n    fontSize: 12,\n    fontWeight: \"400\" as const,\n  },\n  link: {\n    fontSize: 16,\n    fontWeight: \"400\" as const,\n  },\n  number: {\n    fontSize: 48,\n    fontWeight: \"700\" as const,\n  },\n};\n\nexport const Fonts = Platform.select({\n  ios: {\n    sans: \"system-ui\",\n    serif: \"ui-serif\",\n    rounded: \"ui-rounded\",\n    mono: \"ui-monospace\",\n  },\n  default: {\n    sans: \"normal\",\n    serif: \"serif\",\n    rounded: \"normal\",\n    mono: \"monospace\",\n  },\n  web: {\n    sans: \"system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif\",\n    serif: \"Georgia, 'Times New Roman', serif\",\n    rounded: \"'SF Pro Rounded', 'Hiragino Maru Gothic ProN', Meiryo, 'MS PGothic', sans-serif\",\n    mono: \"SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace\",\n  },\n});\n\nexport const Shadows = {\n  card: {\n    shadowColor: \"#000\",\n    shadowOffset: { width: 0, height: 1 },\n    shadowOpacity: 0.05,\n    shadowRadius: 4,\n    elevation: 2,\n  },\n  fab: {\n    shadowColor: \"#000\",\n    shadowOffset: { width: 0, height: 2 },\n    shadowOpacity: 0.1,\n    shadowRadius: 4,\n    elevation: 4,\n  },\n};\n","path":null,"size_bytes":3059,"size_tokens":null},"Mobile-Architect/client/navigation/HistoryStackNavigator.tsx":{"content":"import React from \"react\";\nimport { createNativeStackNavigator } from \"@react-navigation/native-stack\";\nimport HistoryScreen from \"@/screens/HistoryScreen\";\nimport { useScreenOptions } from \"@/hooks/useScreenOptions\";\n\nexport type HistoryStackParamList = {\n  History: undefined;\n};\n\nconst Stack = createNativeStackNavigator<HistoryStackParamList>();\n\nexport default function HistoryStackNavigator() {\n  const screenOptions = useScreenOptions();\n\n  return (\n    <Stack.Navigator screenOptions={screenOptions}>\n      <Stack.Screen\n        name=\"History\"\n        component={HistoryScreen}\n        options={{\n          headerTitle: \"Activity\",\n        }}\n      />\n    </Stack.Navigator>\n  );\n}\n","path":null,"size_bytes":690,"size_tokens":null},"Mobile-Architect/scripts/build.js":{"content":"const fs = require(\"fs\");\nconst path = require(\"path\");\nconst { spawn } = require(\"child_process\");\nconst { Readable } = require(\"stream\");\nconst { pipeline } = require(\"stream/promises\");\n\nlet metroProcess = null;\n\nfunction exitWithError(message) {\n  console.error(message);\n  if (metroProcess) {\n    metroProcess.kill();\n  }\n  process.exit(1);\n}\n\nfunction setupSignalHandlers() {\n  const cleanup = () => {\n    if (metroProcess) {\n      console.log(\"Cleaning up Metro process...\");\n      metroProcess.kill();\n    }\n    process.exit(0);\n  };\n\n  process.on(\"SIGINT\", cleanup);\n  process.on(\"SIGTERM\", cleanup);\n  process.on(\"SIGHUP\", cleanup);\n}\n\nfunction stripProtocol(domain) {\n  let urlString = domain.trim();\n\n  if (!/^https?:\\/\\//i.test(urlString)) {\n    urlString = `https://${urlString}`;\n  }\n\n  return new URL(urlString).host;\n}\n\nfunction getDeploymentDomain() {\n  // Check Replit deployment environment variables first\n  if (process.env.REPLIT_INTERNAL_APP_DOMAIN) {\n    return stripProtocol(process.env.REPLIT_INTERNAL_APP_DOMAIN);\n  }\n\n  if (process.env.REPLIT_DEV_DOMAIN) {\n    return stripProtocol(process.env.REPLIT_DEV_DOMAIN);\n  }\n\n  if (process.env.EXPO_PUBLIC_DOMAIN) {\n    return stripProtocol(process.env.EXPO_PUBLIC_DOMAIN);\n  }\n\n  console.error(\n    \"ERROR: No deployment domain found. Set REPLIT_INTERNAL_APP_DOMAIN, REPLIT_DEV_DOMAIN, or EXPO_PUBLIC_DOMAIN\",\n  );\n  process.exit(1);\n}\n\nfunction prepareDirectories(timestamp) {\n  console.log(\"Preparing build directories...\");\n\n  if (fs.existsSync(\"static-build\")) {\n    fs.rmSync(\"static-build\", { recursive: true });\n  }\n\n  const dirs = [\n    path.join(\"static-build\", timestamp, \"_expo\", \"static\", \"js\", \"ios\"),\n    path.join(\"static-build\", timestamp, \"_expo\", \"static\", \"js\", \"android\"),\n    path.join(\"static-build\", \"ios\"),\n    path.join(\"static-build\", \"android\"),\n  ];\n\n  for (const dir of dirs) {\n    fs.mkdirSync(dir, { recursive: true });\n  }\n\n  console.log(\"Build:\", timestamp);\n}\n\nfunction clearMetroCache() {\n  console.log(\"Clearing Metro cache...\");\n\n  const cacheDirs = [\n    ...fs.globSync(\".metro-cache\"),\n    ...fs.globSync(\"node_modules/.cache/metro\"),\n  ];\n\n  for (const dir of cacheDirs) {\n    fs.rmSync(dir, { recursive: true, force: true });\n  }\n\n  console.log(\"Cache cleared\");\n}\n\nasync function checkMetroHealth() {\n  try {\n    const response = await fetch(\"http://localhost:8081/status\", {\n      signal: AbortSignal.timeout(5000),\n    });\n    return response.ok;\n  } catch {\n    return false;\n  }\n}\n\nasync function startMetro(expoPublicDomain) {\n  const isRunning = await checkMetroHealth();\n  if (isRunning) {\n    console.log(\"Metro already running\");\n    return;\n  }\n\n  console.log(\"Starting Metro...\");\n  console.log(`Setting EXPO_PUBLIC_DOMAIN=${expoPublicDomain}`);\n  const env = {\n    ...process.env,\n    EXPO_PUBLIC_DOMAIN: expoPublicDomain,\n  };\n  metroProcess = spawn(\"npm\", [\"run\", \"expo:start:static:build\"], {\n    stdio: [\"ignore\", \"pipe\", \"pipe\"],\n    detached: false,\n    env,\n  });\n\n  if (metroProcess.stdout) {\n    metroProcess.stdout.on(\"data\", (data) => {\n      const output = data.toString().trim();\n      if (output) console.log(`[Metro] ${output}`);\n    });\n  }\n  if (metroProcess.stderr) {\n    metroProcess.stderr.on(\"data\", (data) => {\n      const output = data.toString().trim();\n      if (output) console.error(`[Metro Error] ${output}`);\n    });\n  }\n\n  for (let i = 0; i < 60; i++) {\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n\n    const healthy = await checkMetroHealth();\n    if (healthy) {\n      console.log(\"Metro ready\");\n      return;\n    }\n  }\n\n  console.error(\"Metro timeout\");\n  process.exit(1);\n}\n\nasync function downloadFile(url, outputPath) {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), 120_000);\n\n  try {\n    console.log(`Downloading: ${url}`);\n    const response = await fetch(url, { signal: controller.signal });\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n\n    const file = fs.createWriteStream(outputPath);\n    await pipeline(Readable.fromWeb(response.body), file);\n\n    const fileSize = fs.statSync(outputPath).size;\n\n    if (fileSize === 0) {\n      fs.unlinkSync(outputPath);\n      throw new Error(\"Downloaded file is empty\");\n    }\n  } catch (error) {\n    if (fs.existsSync(outputPath)) {\n      fs.unlinkSync(outputPath);\n    }\n\n    if (error.name === \"AbortError\") {\n      throw new Error(`Download timeout after 2m: ${url}`);\n    }\n    throw error;\n  } finally {\n    clearTimeout(timeoutId);\n  }\n}\n\nasync function downloadBundle(platform, timestamp) {\n  const url = new URL(\"http://localhost:8081/client/index.bundle\");\n  url.searchParams.set(\"platform\", platform);\n  url.searchParams.set(\"dev\", \"false\");\n  url.searchParams.set(\"hot\", \"false\");\n  url.searchParams.set(\"lazy\", \"false\");\n  url.searchParams.set(\"minify\", \"true\");\n\n  const output = path.join(\n    \"static-build\",\n    timestamp,\n    \"_expo\",\n    \"static\",\n    \"js\",\n    platform,\n    \"bundle.js\",\n  );\n\n  console.log(`Fetching ${platform} bundle...`);\n  await downloadFile(url.toString(), output);\n  console.log(`${platform} bundle ready`);\n}\n\nasync function downloadManifest(platform) {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), 300_000);\n\n  try {\n    console.log(`Fetching ${platform} manifest...`);\n    const response = await fetch(\"http://localhost:8081/manifest\", {\n      headers: { \"expo-platform\": platform },\n      signal: controller.signal,\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n\n    const manifest = await response.json();\n    console.log(`${platform} manifest ready`);\n    return manifest;\n  } catch (error) {\n    if (error.name === \"AbortError\") {\n      throw new Error(\n        `Manifest download timeout after 5m for platform: ${platform}`,\n      );\n    }\n    throw error;\n  } finally {\n    clearTimeout(timeoutId);\n  }\n}\n\nasync function downloadBundlesAndManifests(timestamp) {\n  console.log(\"Downloading bundles and manifests...\");\n  console.log(\"This may take several minutes for production builds...\");\n\n  try {\n    const results = await Promise.allSettled([\n      downloadBundle(\"ios\", timestamp),\n      downloadBundle(\"android\", timestamp),\n      downloadManifest(\"ios\"),\n      downloadManifest(\"android\"),\n    ]);\n\n    const failures = results\n      .map((result, index) => ({ result, index }))\n      .filter(({ result }) => result.status === \"rejected\");\n\n    if (failures.length > 0) {\n      const errorMessages = failures.map(({ result, index }) => {\n        const names = [\n          \"iOS bundle\",\n          \"Android bundle\",\n          \"iOS manifest\",\n          \"Android manifest\",\n        ];\n        return `  - ${names[index]}: ${result.reason?.message || result.reason}`;\n      });\n\n      exitWithError(`Download failed:\\n${errorMessages.join(\"\\n\")}`);\n    }\n\n    const iosManifest =\n      results[2].status === \"fulfilled\" ? results[2].value : null;\n    const androidManifest =\n      results[3].status === \"fulfilled\" ? results[3].value : null;\n\n    console.log(\"All downloads completed successfully\");\n    return { ios: iosManifest, android: androidManifest };\n  } catch (error) {\n    exitWithError(`Unexpected download error: ${error.message}`);\n  }\n}\n\nfunction extractAssets(timestamp) {\n  const bundles = {\n    ios: fs.readFileSync(\n      path.join(\n        \"static-build\",\n        timestamp,\n        \"_expo\",\n        \"static\",\n        \"js\",\n        \"ios\",\n        \"bundle.js\",\n      ),\n      \"utf-8\",\n    ),\n    android: fs.readFileSync(\n      path.join(\n        \"static-build\",\n        timestamp,\n        \"_expo\",\n        \"static\",\n        \"js\",\n        \"android\",\n        \"bundle.js\",\n      ),\n      \"utf-8\",\n    ),\n  };\n\n  const assetsMap = new Map();\n  const assetPattern =\n    /httpServerLocation:\"([^\"]+)\"[^}]*hash:\"([^\"]+)\"[^}]*name:\"([^\"]+)\"[^}]*type:\"([^\"]+)\"/g;\n\n  const extractFromBundle = (bundle, platform) => {\n    for (const match of bundle.matchAll(assetPattern)) {\n      const originalPath = match[1];\n      const filename = match[3] + \".\" + match[4];\n\n      const tempUrl = new URL(`http://localhost:8081${originalPath}`);\n      const unstablePath = tempUrl.searchParams.get(\"unstable_path\");\n\n      if (!unstablePath) {\n        throw new Error(`Asset missing unstable_path: ${originalPath}`);\n      }\n\n      const decodedPath = decodeURIComponent(unstablePath);\n      const key = path.posix.join(decodedPath, filename);\n\n      if (!assetsMap.has(key)) {\n        const asset = {\n          url: path.posix.join(\"/\", decodedPath, filename),\n          originalPath: originalPath,\n          filename: filename,\n          relativePath: decodedPath,\n          hash: match[2],\n          platforms: new Set(),\n        };\n\n        assetsMap.set(key, asset);\n      }\n      assetsMap.get(key).platforms.add(platform);\n    }\n  };\n\n  extractFromBundle(bundles.ios, \"ios\");\n  extractFromBundle(bundles.android, \"android\");\n\n  return Array.from(assetsMap.values());\n}\n\nasync function downloadAssets(assets, timestamp) {\n  if (assets.length === 0) {\n    return 0;\n  }\n\n  console.log(\"Downloading assets...\");\n  let successCount = 0;\n  const failures = [];\n\n  const downloadPromises = assets.map(async (asset) => {\n    const platform = Array.from(asset.platforms)[0];\n\n    const tempUrl = new URL(`http://localhost:8081${asset.originalPath}`);\n    const unstablePath = tempUrl.searchParams.get(\"unstable_path\");\n\n    if (!unstablePath) {\n      throw new Error(`Asset missing unstable_path: ${asset.originalPath}`);\n    }\n\n    const decodedPath = decodeURIComponent(unstablePath);\n    const metroUrl = new URL(\n      `http://localhost:8081${path.posix.join(\"/assets\", decodedPath, asset.filename)}`,\n    );\n    metroUrl.searchParams.set(\"platform\", platform);\n    metroUrl.searchParams.set(\"hash\", asset.hash);\n\n    const outputDir = path.join(\n      \"static-build\",\n      timestamp,\n      \"_expo\",\n      \"static\",\n      \"js\",\n      asset.relativePath,\n    );\n    fs.mkdirSync(outputDir, { recursive: true });\n    const output = path.join(outputDir, asset.filename);\n\n    try {\n      await downloadFile(metroUrl.toString(), output);\n      successCount++;\n    } catch (error) {\n      failures.push({\n        filename: asset.filename,\n        error: error.message,\n        url: metroUrl.toString(),\n      });\n    }\n  });\n\n  await Promise.all(downloadPromises);\n\n  if (failures.length > 0) {\n    const errorMsg =\n      `Failed to download ${failures.length} asset(s):\\n` +\n      failures\n        .map((f) => `  - ${f.filename}: ${f.error} (${f.url})`)\n        .join(\"\\n\");\n    exitWithError(errorMsg);\n  }\n\n  console.log(`Downloaded ${successCount} assets`);\n  return successCount;\n}\n\nfunction updateBundleUrls(timestamp, baseUrl) {\n  const updateForPlatform = (platform) => {\n    const bundlePath = path.join(\n      \"static-build\",\n      timestamp,\n      \"_expo\",\n      \"static\",\n      \"js\",\n      platform,\n      \"bundle.js\",\n    );\n    let bundle = fs.readFileSync(bundlePath, \"utf-8\");\n\n    bundle = bundle.replace(\n      /httpServerLocation:\"(\\/[^\"]+)\"/g,\n      (_match, capturedPath) => {\n        const tempUrl = new URL(`http://localhost:8081${capturedPath}`);\n        const unstablePath = tempUrl.searchParams.get(\"unstable_path\");\n\n        if (!unstablePath) {\n          throw new Error(\n            `Asset missing unstable_path in bundle: ${capturedPath}`,\n          );\n        }\n\n        const decodedPath = decodeURIComponent(unstablePath);\n        return `httpServerLocation:\"${baseUrl}/${timestamp}/_expo/static/js/${decodedPath}\"`;\n      },\n    );\n\n    fs.writeFileSync(bundlePath, bundle);\n  };\n\n  updateForPlatform(\"ios\");\n  updateForPlatform(\"android\");\n  console.log(\"Updated bundle URLs\");\n}\n\nfunction updateManifests(manifests, timestamp, baseUrl, assetsByHash) {\n  const updateForPlatform = (platform, manifest) => {\n    if (!manifest.launchAsset || !manifest.extra) {\n      exitWithError(`Malformed manifest for ${platform}`);\n    }\n\n    manifest.launchAsset.url = `${baseUrl}/${timestamp}/_expo/static/js/${platform}/bundle.js`;\n    manifest.launchAsset.key = `bundle-${timestamp}`;\n    manifest.createdAt = new Date(\n      Number(timestamp.split(\"-\")[0]),\n    ).toISOString();\n    manifest.extra.expoClient.hostUri =\n      baseUrl.replace(\"https://\", \"\") + \"/\" + platform;\n    manifest.extra.expoGo.debuggerHost =\n      baseUrl.replace(\"https://\", \"\") + \"/\" + platform;\n    manifest.extra.expoGo.packagerOpts.dev = false;\n\n    if (manifest.assets && manifest.assets.length > 0) {\n      manifest.assets.forEach((asset) => {\n        if (!asset.url) return;\n\n        const hash = asset.hash;\n        if (!hash) return;\n\n        const assetInfo = assetsByHash.get(hash);\n        if (!assetInfo) return;\n\n        asset.url = `${baseUrl}/${timestamp}/_expo/static/js/${assetInfo.relativePath}/${assetInfo.filename}`;\n      });\n    }\n\n    fs.writeFileSync(\n      path.join(\"static-build\", platform, \"manifest.json\"),\n      JSON.stringify(manifest, null, 2),\n    );\n  };\n\n  updateForPlatform(\"ios\", manifests.ios);\n  updateForPlatform(\"android\", manifests.android);\n  console.log(\"Manifests updated\");\n}\n\nasync function main() {\n  console.log(\"Building static Expo Go deployment...\");\n\n  setupSignalHandlers();\n\n  const domain = getDeploymentDomain();\n  const baseUrl = `https://${domain}`;\n  const timestamp = `${Date.now()}-${process.pid}`;\n\n  prepareDirectories(timestamp);\n  clearMetroCache();\n\n  await startMetro(domain);\n\n  const downloadTimeout = 300000;\n  const downloadPromise = downloadBundlesAndManifests(timestamp);\n  const timeoutPromise = new Promise((_, reject) => {\n    setTimeout(() => {\n      reject(\n        new Error(\n          `Overall download timeout after ${downloadTimeout / 1000} seconds. ` +\n            \"Metro may be struggling to generate bundles. Check Metro logs above.\",\n        ),\n      );\n    }, downloadTimeout);\n  });\n\n  const manifests = await Promise.race([downloadPromise, timeoutPromise]);\n\n  console.log(\"Processing assets...\");\n  const assets = extractAssets(timestamp);\n  console.log(\"Found\", assets.length, \"unique asset(s)\");\n\n  const assetsByHash = new Map();\n  for (const asset of assets) {\n    assetsByHash.set(asset.hash, {\n      relativePath: asset.relativePath,\n      filename: asset.filename,\n    });\n  }\n\n  const assetCount = await downloadAssets(assets, timestamp);\n\n  if (assetCount > 0) {\n    updateBundleUrls(timestamp, baseUrl);\n  }\n\n  console.log(\"Updating manifests and creating landing page...\");\n  updateManifests(manifests, timestamp, baseUrl, assetsByHash);\n\n  console.log(\"Build complete! Deploy to:\", baseUrl);\n\n  if (metroProcess) {\n    metroProcess.kill();\n  }\n  process.exit(0);\n}\n\nmain().catch((error) => {\n  console.error(\"Build failed:\", error.message);\n  if (metroProcess) {\n    metroProcess.kill();\n  }\n  process.exit(1);\n});\n","path":null,"size_bytes":14884,"size_tokens":null},"Mobile-Architect/client/lib/query-client.ts":{"content":"import { QueryClient, QueryFunction } from \"@tanstack/react-query\";\n\n/**\n * Gets the base URL for the Express API server (e.g., \"http://localhost:3000\")\n * @returns {string} The API base URL\n */\nexport function getApiUrl(): string {\n  let host = process.env.EXPO_PUBLIC_DOMAIN;\n\n  if (!host) {\n    throw new Error(\"EXPO_PUBLIC_DOMAIN is not set\");\n  }\n\n  let url = new URL(`https://${host}`);\n\n  return url.href;\n}\n\nasync function throwIfResNotOk(res: Response) {\n  if (!res.ok) {\n    const text = (await res.text()) || res.statusText;\n    throw new Error(`${res.status}: ${text}`);\n  }\n}\n\nexport async function apiRequest(\n  method: string,\n  route: string,\n  data?: unknown | undefined,\n): Promise<Response> {\n  const baseUrl = getApiUrl();\n  const url = new URL(route, baseUrl);\n\n  const res = await fetch(url, {\n    method,\n    headers: data ? { \"Content-Type\": \"application/json\" } : {},\n    body: data ? JSON.stringify(data) : undefined,\n    credentials: \"include\",\n  });\n\n  await throwIfResNotOk(res);\n  return res;\n}\n\ntype UnauthorizedBehavior = \"returnNull\" | \"throw\";\nexport const getQueryFn: <T>(options: {\n  on401: UnauthorizedBehavior;\n}) => QueryFunction<T> =\n  ({ on401: unauthorizedBehavior }) =>\n  async ({ queryKey }) => {\n    const baseUrl = getApiUrl();\n    const url = new URL(queryKey.join(\"/\") as string, baseUrl);\n\n    const res = await fetch(url, {\n      credentials: \"include\",\n    });\n\n    if (unauthorizedBehavior === \"returnNull\" && res.status === 401) {\n      return null;\n    }\n\n    await throwIfResNotOk(res);\n    return await res.json();\n  };\n\nexport const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      queryFn: getQueryFn({ on401: \"throw\" }),\n      refetchInterval: false,\n      refetchOnWindowFocus: false,\n      staleTime: Infinity,\n      retry: false,\n    },\n    mutations: {\n      retry: false,\n    },\n  },\n});\n","path":null,"size_bytes":1876,"size_tokens":null},"Mobile-Architect/client/components/FloatingActionButton.tsx":{"content":"import React from \"react\";\nimport { StyleSheet, Pressable, ViewStyle } from \"react-native\";\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from \"react-native-reanimated\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Shadows, BorderRadius, Spacing } from \"@/constants/theme\";\n\ninterface FloatingActionButtonProps {\n  onPress: () => void;\n  icon?: string;\n  style?: ViewStyle;\n}\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nexport function FloatingActionButton({ onPress, icon = \"plus\", style }: FloatingActionButtonProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handlePressIn = () => {\n    scale.value = withSpring(0.9, { damping: 15, stiffness: 150 });\n  };\n\n  const handlePressOut = () => {\n    scale.value = withSpring(1, { damping: 15, stiffness: 150 });\n  };\n\n  return (\n    <AnimatedPressable\n      onPress={onPress}\n      onPressIn={handlePressIn}\n      onPressOut={handlePressOut}\n      style={[\n        styles.fab,\n        { backgroundColor: theme.primary, ...Shadows.fab },\n        animatedStyle,\n        style,\n      ]}\n    >\n      <Feather name={icon as any} size={24} color=\"#FFFFFF\" />\n    </AnimatedPressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  fab: {\n    width: 56,\n    height: 56,\n    borderRadius: BorderRadius.full,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    position: \"absolute\",\n    right: Spacing.lg,\n  },\n});\n","path":null,"size_bytes":1597,"size_tokens":null},"Mobile-Architect/client/components/ErrorFallback.tsx":{"content":"import React, { useState } from \"react\";\nimport { reloadAppAsync } from \"expo\";\nimport {\n  StyleSheet,\n  View,\n  Pressable,\n  ScrollView,\n  Text,\n  Modal,\n} from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius, Fonts } from \"@/constants/theme\";\n\nexport type ErrorFallbackProps = {\n  error: Error;\n  resetError: () => void;\n};\n\nexport function ErrorFallback({ error, resetError }: ErrorFallbackProps) {\n  const { theme } = useTheme();\n  const [isModalVisible, setIsModalVisible] = useState(false);\n\n  const handleRestart = async () => {\n    try {\n      await reloadAppAsync();\n    } catch (restartError) {\n      console.error(\"Failed to restart app:\", restartError);\n      resetError();\n    }\n  };\n\n  const formatErrorDetails = (): string => {\n    let details = `Error: ${error.message}\\n\\n`;\n    if (error.stack) {\n      details += `Stack Trace:\\n${error.stack}`;\n    }\n    return details;\n  };\n\n  return (\n    <ThemedView style={styles.container}>\n      {__DEV__ ? (\n        <Pressable\n          onPress={() => setIsModalVisible(true)}\n          style={({ pressed }) => [\n            styles.topButton,\n            {\n              backgroundColor: theme.backgroundDefault,\n              opacity: pressed ? 0.8 : 1,\n            },\n          ]}\n        >\n          <Feather name=\"alert-circle\" size={20} color={theme.text} />\n        </Pressable>\n      ) : null}\n\n      <View style={styles.content}>\n        <ThemedText type=\"h1\" style={styles.title}>\n          Something went wrong\n        </ThemedText>\n\n        <ThemedText type=\"body\" style={styles.message}>\n          Please reload the app to continue.\n        </ThemedText>\n\n        <Pressable\n          onPress={handleRestart}\n          style={({ pressed }) => [\n            styles.button,\n            {\n              backgroundColor: theme.link,\n              opacity: pressed ? 0.9 : 1,\n              transform: [{ scale: pressed ? 0.98 : 1 }],\n            },\n          ]}\n        >\n          <ThemedText\n            type=\"body\"\n            style={[styles.buttonText, { color: theme.buttonText }]}\n          >\n            Try Again\n          </ThemedText>\n        </Pressable>\n      </View>\n\n      {__DEV__ ? (\n        <Modal\n          visible={isModalVisible}\n          animationType=\"slide\"\n          transparent={true}\n          onRequestClose={() => setIsModalVisible(false)}\n        >\n          <View style={styles.modalOverlay}>\n            <ThemedView style={styles.modalContainer}>\n              <View style={styles.modalHeader}>\n                <ThemedText type=\"h2\" style={styles.modalTitle}>\n                  Error Details\n                </ThemedText>\n                <Pressable\n                  onPress={() => setIsModalVisible(false)}\n                  style={({ pressed }) => [\n                    styles.closeButton,\n                    { opacity: pressed ? 0.6 : 1 },\n                  ]}\n                >\n                  <Feather name=\"x\" size={24} color={theme.text} />\n                </Pressable>\n              </View>\n\n              <ScrollView\n                style={styles.modalScrollView}\n                contentContainerStyle={styles.modalScrollContent}\n                showsVerticalScrollIndicator\n              >\n                <View\n                  style={[\n                    styles.errorContainer,\n                    { backgroundColor: theme.backgroundDefault },\n                  ]}\n                >\n                  <Text\n                    style={[\n                      styles.errorText,\n                      {\n                        color: theme.text,\n                        fontFamily: Fonts?.mono || \"monospace\",\n                      },\n                    ]}\n                    selectable\n                  >\n                    {formatErrorDetails()}\n                  </Text>\n                </View>\n              </ScrollView>\n            </ThemedView>\n          </View>\n        </Modal>\n      ) : null}\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    width: \"100%\",\n    height: \"100%\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    padding: Spacing[\"2xl\"],\n  },\n  content: {\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    gap: Spacing.lg,\n    width: \"100%\",\n    maxWidth: 600,\n  },\n  title: {\n    textAlign: \"center\",\n    lineHeight: 40,\n  },\n  message: {\n    textAlign: \"center\",\n    opacity: 0.7,\n    lineHeight: 24,\n  },\n  topButton: {\n    position: \"absolute\",\n    top: Spacing[\"2xl\"] + Spacing.lg,\n    right: Spacing.lg,\n    width: 44,\n    height: 44,\n    borderRadius: BorderRadius.md,\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    zIndex: 10,\n  },\n  button: {\n    paddingVertical: Spacing.lg,\n    borderRadius: BorderRadius.md,\n    paddingHorizontal: Spacing[\"2xl\"],\n    minWidth: 200,\n    shadowColor: \"#000\",\n    shadowOffset: {\n      width: 0,\n      height: 2,\n    },\n    shadowOpacity: 0.1,\n    shadowRadius: 4,\n    elevation: 3,\n  },\n  buttonText: {\n    fontWeight: \"600\",\n    textAlign: \"center\",\n    fontSize: 16,\n  },\n  modalOverlay: {\n    flex: 1,\n    backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n    justifyContent: \"flex-end\",\n  },\n  modalContainer: {\n    width: \"100%\",\n    height: \"90%\",\n    borderTopLeftRadius: BorderRadius.lg,\n    borderTopRightRadius: BorderRadius.lg,\n  },\n  modalHeader: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.lg,\n    paddingTop: Spacing.lg,\n    paddingBottom: Spacing.md,\n    borderBottomWidth: 1,\n    borderBottomColor: \"rgba(128, 128, 128, 0.2)\",\n  },\n  modalTitle: {\n    fontWeight: \"600\",\n  },\n  closeButton: {\n    padding: Spacing.xs,\n  },\n  modalScrollView: {\n    flex: 1,\n  },\n  modalScrollContent: {\n    padding: Spacing.lg,\n  },\n  errorContainer: {\n    width: \"100%\",\n    borderRadius: BorderRadius.md,\n    overflow: \"hidden\",\n    padding: Spacing.lg,\n  },\n  errorText: {\n    fontSize: 12,\n    lineHeight: 18,\n    width: \"100%\",\n  },\n});\n","path":null,"size_bytes":6194,"size_tokens":null},"Mobile-Architect/client/components/SettingsRow.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet, Pressable, Switch } from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\n\ninterface SettingsRowProps {\n  icon?: string;\n  title: string;\n  subtitle?: string;\n  value?: string;\n  isSwitch?: boolean;\n  switchValue?: boolean;\n  onSwitchChange?: (value: boolean) => void;\n  onPress?: () => void;\n  showChevron?: boolean;\n}\n\nexport function SettingsRow({\n  icon,\n  title,\n  subtitle,\n  value,\n  isSwitch,\n  switchValue,\n  onSwitchChange,\n  onPress,\n  showChevron = true,\n}: SettingsRowProps) {\n  const { theme } = useTheme();\n\n  const content = (\n    <View style={[styles.container, { backgroundColor: theme.backgroundDefault }]}>\n      {icon ? (\n        <View style={[styles.iconContainer, { backgroundColor: theme.primary + \"20\" }]}>\n          <Feather name={icon as any} size={18} color={theme.primary} />\n        </View>\n      ) : null}\n      <View style={styles.content}>\n        <ThemedText style={styles.title}>{title}</ThemedText>\n        {subtitle ? (\n          <ThemedText style={[styles.subtitle, { color: theme.textSecondary }]}>\n            {subtitle}\n          </ThemedText>\n        ) : null}\n      </View>\n      {isSwitch ? (\n        <Switch\n          value={switchValue}\n          onValueChange={onSwitchChange}\n          trackColor={{ false: theme.backgroundSecondary, true: theme.primary + \"80\" }}\n          thumbColor={switchValue ? theme.primary : theme.backgroundTertiary}\n        />\n      ) : value ? (\n        <ThemedText style={[styles.value, { color: theme.textSecondary }]}>\n          {value}\n        </ThemedText>\n      ) : showChevron ? (\n        <Feather name=\"chevron-right\" size={20} color={theme.textSecondary} />\n      ) : null}\n    </View>\n  );\n\n  if (onPress && !isSwitch) {\n    return <Pressable onPress={onPress}>{content}</Pressable>;\n  }\n\n  return content;\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.md,\n    marginBottom: Spacing.sm,\n  },\n  iconContainer: {\n    width: 36,\n    height: 36,\n    borderRadius: BorderRadius.sm,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    marginRight: Spacing.md,\n  },\n  content: {\n    flex: 1,\n  },\n  title: {\n    fontSize: 16,\n    fontWeight: \"500\",\n  },\n  subtitle: {\n    fontSize: 13,\n    marginTop: 2,\n  },\n  value: {\n    fontSize: 14,\n  },\n});\n","path":null,"size_bytes":2573,"size_tokens":null},"Mobile-Architect/client/components/WaitTimeIndicator.tsx":{"content":"import React, { useEffect } from \"react\";\nimport { View, StyleSheet } from \"react-native\";\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withSpring,\n  withRepeat,\n  withSequence,\n  withTiming,\n  interpolate,\n} from \"react-native-reanimated\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\n\ninterface WaitTimeIndicatorProps {\n  minutes: number;\n  confidence: number;\n  size?: number;\n}\n\nfunction getWaitColor(minutes: number, theme: any): string {\n  if (minutes < 15) return theme.success;\n  if (minutes < 30) return theme.warning;\n  return theme.error;\n}\n\nexport function WaitTimeIndicator({ minutes, confidence, size = 180 }: WaitTimeIndicatorProps) {\n  const { theme } = useTheme();\n  const progress = useSharedValue(0);\n  const pulse = useSharedValue(1);\n\n  useEffect(() => {\n    progress.value = withSpring(Math.min(minutes / 60, 1), { damping: 15, stiffness: 80 });\n    pulse.value = withRepeat(\n      withSequence(\n        withTiming(1.02, { duration: 1000 }),\n        withTiming(1, { duration: 1000 })\n      ),\n      -1,\n      true\n    );\n  }, [minutes]);\n\n  const waitColor = getWaitColor(minutes, theme);\n\n  const circleStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: pulse.value }],\n  }));\n\n  const progressStyle = useAnimatedStyle(() => {\n    const rotation = interpolate(progress.value, [0, 1], [0, 360]);\n    return {\n      transform: [{ rotate: `${rotation}deg` }],\n    };\n  });\n\n  return (\n    <View style={[styles.container, { width: size, height: size }]}>\n      <Animated.View\n        style={[\n          styles.circle,\n          {\n            width: size,\n            height: size,\n            borderRadius: size / 2,\n            backgroundColor: theme.backgroundDefault,\n            borderColor: waitColor,\n            borderWidth: 4,\n          },\n          circleStyle,\n        ]}\n      >\n        <View style={styles.content}>\n          <ThemedText style={[styles.minutes, { color: waitColor, fontSize: size * 0.28 }]}>\n            {minutes}\n          </ThemedText>\n          <ThemedText style={[styles.label, { color: theme.textSecondary }]}>\n            min wait\n          </ThemedText>\n        </View>\n      </Animated.View>\n      <View style={styles.confidenceContainer}>\n        <ThemedText style={[styles.confidence, { color: theme.textSecondary }]}>\n          {Math.round(confidence * 100)}% confident\n        </ThemedText>\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  circle: {\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  content: {\n    alignItems: \"center\",\n  },\n  minutes: {\n    fontWeight: \"700\",\n  },\n  label: {\n    fontSize: 14,\n    marginTop: Spacing.xs,\n  },\n  confidenceContainer: {\n    marginTop: Spacing.md,\n  },\n  confidence: {\n    fontSize: 14,\n  },\n});\n","path":null,"size_bytes":2950,"size_tokens":null},"Mobile-Architect/design_guidelines.md":{"content":"# QueueSense Design Guidelines\n\n## Platform Note\n**IMPORTANT**: The requirements specify Flutter/Material 3, but the stack blueprint indicates Expo. These guidelines are optimized for **React Native/Expo** with Material Design principles adapted for iOS/Android cross-platform development.\n\n---\n\n## Architecture Decisions\n\n### Authentication\n**No Authentication Required**\n- The app uses anonymous check-ins with device fingerprinting to prevent duplicates\n- No login, signup, or account management screens needed\n- Device ID is generated and stored locally on first launch\n- **Include a Settings screen** with:\n  - App preferences (notifications, location permissions)\n  - Privacy policy link\n  - Terms of service link\n  - About section with app version\n\n### Navigation Structure\n**Tab Navigation (4 tabs + Floating Action Button)**\n\nThe app has 4 distinct feature areas plus a core check-in action:\n\n1. **Home Tab** - Browse locations and view queue status\n2. **Predictions Tab** - View best time recommendations and trends\n3. **History Tab** - Recent check-ins and saved locations\n4. **Settings Tab** - App preferences and information\n\n**Floating Action Button (FAB)** - Check-in action (positioned bottom-right, above tab bar)\n\n---\n\n## Screen Specifications\n\n### 1. Home Screen (Tab 1)\n**Purpose**: Browse and select locations to view queue status\n\n**Layout**:\n- Header: Custom with app logo/title, search icon (right)\n- Main content: Scrollable with category cards + location list\n- Safe area: top = headerHeight + Spacing.xl, bottom = tabBarHeight + Spacing.xl\n\n**Components**:\n- **Category Selector**: Horizontal scrollable chip group (Bank, Hospital, Government Office)\n- **Location Cards**: Vertical list showing:\n  - Location name and address\n  - Current crowd indicator (color-coded dot: green/yellow/red)\n  - Estimated wait time badge\n  - Distance from user (optional)\n- **Empty State**: \"No locations nearby\" with illustration\n\n**Interactions**:\n- Tap category chip to filter locations\n- Tap location card to navigate to Queue Status Screen\n- Pull-to-refresh to update queue data\n\n---\n\n### 2. Queue Status Screen (Stack Screen)\n**Purpose**: View live queue data for selected location\n\n**Layout**:\n- Header: Default navigation with location name, back button (left), favorite icon (right)\n- Main content: Scrollable with metric cards\n- Safe area: top = Spacing.xl, bottom = insets.bottom + Spacing.xl\n\n**Components**:\n- **Wait Time Hero**: Large circular animated indicator showing estimated minutes\n  - Color transitions based on wait time (green < 15min, yellow 15-30min, red > 30min)\n  - Confidence percentage below (e.g., \"85% confident\")\n- **Trend Indicator**: Arrow icon + text (↑ Increasing / → Stable / ↓ Decreasing)\n- **Current Queue Info Card**:\n  - People in queue (approximate count)\n  - Last updated timestamp\n  - Data freshness indicator\n- **Line Graph**: 24-hour trend showing historical wait times\n- **Check-in Prompt**: Banner encouraging user to contribute data\n\n**Interactions**:\n- Favorite icon toggles saved status\n- Graph is horizontally scrollable for past days\n- Tap check-in banner to open check-in modal\n\n---\n\n### 3. Predictions Screen (Tab 2)\n**Purpose**: View best time recommendations and patterns\n\n**Layout**:\n- Header: Custom with \"Best Times\" title\n- Main content: Scrollable list\n- Safe area: top = headerHeight + Spacing.xl, bottom = tabBarHeight + Spacing.xl\n\n**Components**:\n- **Today's Recommendation Card**:\n  - \"Best time to visit: 2:00 PM - 3:30 PM\"\n  - Reason explanation (e.g., \"Historically low crowd\")\n  - Quick action button to set notification\n- **Heatmap Grid**: 7-day × 24-hour grid showing crowd density\n  - Color-coded cells (light = low wait, dark = high wait)\n  - Tap cell to see specific time details\n- **Pattern Insights**: Text summaries like:\n  - \"Tuesdays are busiest between 10-11 AM\"\n  - \"Fridays after 4 PM have shortest waits\"\n\n---\n\n### 4. History Screen (Tab 3)\n**Purpose**: View recent check-ins and saved locations\n\n**Layout**:\n- Header: Custom with \"Activity\" title\n- Main content: Scrollable list with sections\n- Safe area: top = headerHeight + Spacing.xl, bottom = tabBarHeight + Spacing.xl\n\n**Components**:\n- **Saved Locations Section**: Horizontal scrollable cards (swipe to remove)\n- **Recent Check-ins Section**: Vertical list showing:\n  - Location name\n  - Check-in timestamp\n  - Queue position at time of check-in\n  - Accuracy indicator (if prediction was accurate)\n- **Empty State**: \"No check-ins yet\" with illustration\n\n---\n\n### 5. Settings Screen (Tab 4)\n**Purpose**: App configuration and information\n\n**Layout**:\n- Header: Custom with \"Settings\" title\n- Main content: Scrollable list of grouped settings\n- Safe area: top = headerHeight + Spacing.xl, bottom = tabBarHeight + Spacing.xl\n\n**Components**:\n- **Notifications Group**:\n  - Toggle for low crowd alerts\n  - Toggle for saved location updates\n- **Privacy Group**:\n  - Device ID display (truncated)\n  - \"How we protect your privacy\" info link\n- **About Group**:\n  - App version\n  - Privacy policy link\n  - Terms of service link\n  - Rate app button\n\n---\n\n### 6. Check-in Modal (Native Modal)\n**Purpose**: Submit anonymous queue data\n\n**Layout**:\n- Presented as bottom sheet (75% screen height)\n- Header: Location name, close button (right)\n- Content: Form with submit button at bottom\n- Safe area: bottom = insets.bottom + Spacing.xl\n\n**Components**:\n- **Location Confirmation**: Display selected location name\n- **Queue Position Input**: Number stepper or text input\n  - Label: \"How many people are ahead of you?\"\n  - Validation: 0-200 range\n- **Queue Stage Selector** (Optional): Segmented control\n  - Waiting / In Service / Completing\n- **Submit Button**: Full-width, disabled until valid input\n- **Success Animation**: Checkmark animation on successful submission\n\n**Interactions**:\n- Close button shows confirmation alert if form is dirty\n- Submit button triggers submission and closes modal\n- Success state shows brief confirmation before closing\n\n---\n\n## Design System\n\n### Color Palette\n**Primary Colors** (trustworthy, professional):\n- Primary: #1976D2 (blue - trust, reliability)\n- Secondary: #388E3C (green - positive, available)\n- Background: #FFFFFF (clean, minimal)\n- Surface: #F5F5F5 (subtle cards)\n\n**Status Colors**:\n- Success (low wait): #4CAF50\n- Warning (medium wait): #FF9800\n- Error (high wait): #F44336\n- Info: #2196F3\n\n**Text Colors**:\n- Primary text: #212121\n- Secondary text: #757575\n- Disabled: #BDBDBD\n- Inverse (on dark): #FFFFFF\n\n### Typography\n- Headings: System font, semibold (600)\n- Body: System font, regular (400)\n- Caption: System font, regular (400), smaller size\n- Numbers (wait times): System font, bold (700), tabular nums\n\n### Spacing Scale\n- xs: 4px\n- sm: 8px\n- md: 16px\n- lg: 24px\n- xl: 32px\n- xxl: 48px\n\n### Visual Design Principles\n- **Minimal Shadows**: Use subtle elevation for cards (shadowOpacity: 0.05, shadowRadius: 4)\n- **FAB Shadow** (floating check-in button):\n  - shadowOffset: {width: 0, height: 2}\n  - shadowOpacity: 0.10\n  - shadowRadius: 2\n- **Icons**: Use Feather icons from @expo/vector-icons for consistency\n- **Animations**: Smooth transitions (300ms ease-in-out)\n  - Wait time indicator: Animated circular progress\n  - Crowd trend: Subtle icon pulse for \"increasing\" state\n  - Check-in success: Scale + fade animation\n\n### Interaction Feedback\n- **Touchables**: Subtle scale (0.98) + opacity (0.7) on press\n- **Buttons**: Background color darkens by 10% on press\n- **Cards**: Scale (0.99) on press, no shadow change\n- **FAB**: Scale (0.95) + slight elevation increase on press\n\n---\n\n## Critical Assets\n\n**DO NOT OVERUSE CUSTOM ASSETS**. Use system icons for standard actions.\n\n### Required Generated Assets:\n1. **Empty State Illustrations** (3 unique):\n   - \"No locations nearby\" (simple, minimal line art)\n   - \"No check-ins yet\" (simple, minimal line art)\n   - \"No saved locations\" (simple, minimal line art)\n   - Style: Monochromatic blue line drawings, trustworthy aesthetic\n\n2. **Category Icons** (3):\n   - Bank icon (building with columns)\n   - Hospital icon (cross symbol)\n   - Government office icon (official building)\n   - Style: Outlined, consistent stroke width, blue color\n\n### Standard Icons (use Feather icons):\n- Navigation: home, trending-up, clock, settings\n- Actions: search, heart, plus, x, check\n- Indicators: arrow-up, arrow-right, arrow-down, map-pin\n\n---\n\n## Accessibility Requirements\n- Minimum touch target: 44×44 points\n- Color contrast ratio: 4.5:1 for text, 3:1 for UI components\n- Dynamic type support for text scaling\n- VoiceOver/TalkBack labels for all interactive elements\n- Status indicators include text, not just color\n- Error states provide clear text descriptions","path":null,"size_bytes":8719,"size_tokens":null},"Mobile-Architect/client/navigation/HomeStackNavigator.tsx":{"content":"import React from \"react\";\nimport { createNativeStackNavigator } from \"@react-navigation/native-stack\";\nimport HomeScreen from \"@/screens/HomeScreen\";\nimport QueueStatusScreen from \"@/screens/QueueStatusScreen\";\nimport { HeaderTitle } from \"@/components/HeaderTitle\";\nimport { useScreenOptions } from \"@/hooks/useScreenOptions\";\n\nexport type HomeStackParamList = {\n  Home: undefined;\n  QueueStatus: { locationId: string; locationName: string };\n};\n\nconst Stack = createNativeStackNavigator<HomeStackParamList>();\n\nexport default function HomeStackNavigator() {\n  const screenOptions = useScreenOptions();\n\n  return (\n    <Stack.Navigator screenOptions={screenOptions}>\n      <Stack.Screen\n        name=\"Home\"\n        component={HomeScreen}\n        options={{\n          headerTitle: () => <HeaderTitle title=\"QueueSense\" />,\n        }}\n      />\n      <Stack.Screen\n        name=\"QueueStatus\"\n        component={QueueStatusScreen}\n        options={({ route }) => ({\n          headerTitle: route.params.locationName,\n        })}\n      />\n    </Stack.Navigator>\n  );\n}\n","path":null,"size_bytes":1065,"size_tokens":null},"Mobile-Architect/client/lib/storage.ts":{"content":"import AsyncStorage from \"@react-native-async-storage/async-storage\";\n\nconst SAVED_LOCATIONS_KEY = \"@queuesense_saved_locations\";\nconst RECENT_CHECKINS_KEY = \"@queuesense_recent_checkins\";\n\nexport interface SavedLocation {\n  id: string;\n  name: string;\n  address: string;\n  typeId: string;\n  savedAt: string;\n}\n\nexport interface RecentCheckin {\n  id: string;\n  locationId: string;\n  locationName: string;\n  peopleAhead: number;\n  createdAt: string;\n}\n\nexport async function getSavedLocations(): Promise<SavedLocation[]> {\n  try {\n    const data = await AsyncStorage.getItem(SAVED_LOCATIONS_KEY);\n    return data ? JSON.parse(data) : [];\n  } catch {\n    return [];\n  }\n}\n\nexport async function saveLocation(location: SavedLocation): Promise<void> {\n  try {\n    const locations = await getSavedLocations();\n    const exists = locations.find(l => l.id === location.id);\n    if (!exists) {\n      locations.unshift(location);\n      await AsyncStorage.setItem(SAVED_LOCATIONS_KEY, JSON.stringify(locations.slice(0, 20)));\n    }\n  } catch {\n  }\n}\n\nexport async function removeSavedLocation(locationId: string): Promise<void> {\n  try {\n    const locations = await getSavedLocations();\n    const filtered = locations.filter(l => l.id !== locationId);\n    await AsyncStorage.setItem(SAVED_LOCATIONS_KEY, JSON.stringify(filtered));\n  } catch {\n  }\n}\n\nexport async function isLocationSaved(locationId: string): Promise<boolean> {\n  try {\n    const locations = await getSavedLocations();\n    return locations.some(l => l.id === locationId);\n  } catch {\n    return false;\n  }\n}\n\nexport async function getRecentCheckins(): Promise<RecentCheckin[]> {\n  try {\n    const data = await AsyncStorage.getItem(RECENT_CHECKINS_KEY);\n    return data ? JSON.parse(data) : [];\n  } catch {\n    return [];\n  }\n}\n\nexport async function addRecentCheckin(checkin: RecentCheckin): Promise<void> {\n  try {\n    const checkins = await getRecentCheckins();\n    checkins.unshift(checkin);\n    await AsyncStorage.setItem(RECENT_CHECKINS_KEY, JSON.stringify(checkins.slice(0, 50)));\n  } catch {\n  }\n}\n\nexport async function clearAllData(): Promise<void> {\n  try {\n    await AsyncStorage.multiRemove([SAVED_LOCATIONS_KEY, RECENT_CHECKINS_KEY]);\n  } catch {\n  }\n}\n","path":null,"size_bytes":2222,"size_tokens":null},"Mobile-Architect/drizzle.config.ts":{"content":"import { defineConfig } from \"drizzle-kit\";\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\"DATABASE_URL, ensure the database is provisioned\");\n}\n\nexport default defineConfig({\n  out: \"./migrations\",\n  schema: \"./shared/schema.ts\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL,\n  },\n});\n","path":null,"size_bytes":325,"size_tokens":null},"Mobile-Architect/server/routes.ts":{"content":"import type { Express } from \"express\";\nimport { createServer, type Server } from \"node:http\";\nimport { storage } from \"./storage\";\nimport { calculatePrediction, updateTimeSlotData, getBestTimeToVisit } from \"./prediction\";\nimport { insertCheckinSchema, insertLocationSchema, insertLocationTypeSchema } from \"@shared/schema\";\n\nexport async function registerRoutes(app: Express): Promise<Server> {\n  app.get(\"/api/location-types\", async (req, res) => {\n    try {\n      const types = await storage.getLocationTypes();\n      res.json(types);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to fetch location types\" });\n    }\n  });\n\n  app.get(\"/api/locations\", async (req, res) => {\n    try {\n      const { typeId } = req.query;\n      let locationsList;\n      if (typeId && typeof typeId === \"string\") {\n        locationsList = await storage.getLocationsByType(typeId);\n      } else {\n        locationsList = await storage.getLocations();\n      }\n      res.json(locationsList);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to fetch locations\" });\n    }\n  });\n\n  app.get(\"/api/locations/:id\", async (req, res) => {\n    try {\n      const location = await storage.getLocation(req.params.id);\n      if (!location) {\n        return res.status(404).json({ error: \"Location not found\" });\n      }\n      res.json(location);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to fetch location\" });\n    }\n  });\n\n  app.get(\"/api/locations/:id/queue-status\", async (req, res) => {\n    try {\n      const locationId = req.params.id;\n      const prediction = await calculatePrediction(locationId);\n      const location = await storage.getLocation(locationId);\n      \n      if (!location) {\n        return res.status(404).json({ error: \"Location not found\" });\n      }\n\n      res.json({\n        location,\n        ...prediction,\n        lastUpdated: new Date().toISOString(),\n      });\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to fetch queue status\" });\n    }\n  });\n\n  app.get(\"/api/locations/:id/best-time\", async (req, res) => {\n    try {\n      const bestTimes = await getBestTimeToVisit(req.params.id);\n      res.json(bestTimes);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to fetch best times\" });\n    }\n  });\n\n  app.get(\"/api/locations/:id/history\", async (req, res) => {\n    try {\n      const locationId = req.params.id;\n      const slots = await storage.getTimeSlots(locationId);\n      res.json(slots);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to fetch history\" });\n    }\n  });\n\n  app.post(\"/api/checkin\", async (req, res) => {\n    try {\n      const parsed = insertCheckinSchema.safeParse(req.body);\n      if (!parsed.success) {\n        return res.status(400).json({ error: \"Invalid checkin data\", details: parsed.error.errors });\n      }\n\n      const { locationId, deviceId, peopleAhead, queueStage } = parsed.data;\n\n      const canCheckin = await storage.canDeviceCheckin(deviceId, locationId);\n      if (!canCheckin) {\n        return res.status(429).json({ error: \"Please wait 15 minutes between check-ins at the same location\" });\n      }\n\n      const checkin = await storage.createCheckin({\n        locationId,\n        deviceId,\n        peopleAhead,\n        queueStage: queueStage || \"waiting\",\n      });\n\n      await updateTimeSlotData(locationId, peopleAhead);\n\n      res.status(201).json(checkin);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to create checkin\" });\n    }\n  });\n\n  app.get(\"/api/checkins/device/:deviceId\", async (req, res) => {\n    try {\n      const checkins = await storage.getDeviceCheckins(req.params.deviceId);\n      res.json(checkins);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to fetch checkins\" });\n    }\n  });\n\n  app.post(\"/api/seed\", async (req, res) => {\n    try {\n      const existingTypes = await storage.getLocationTypes();\n      if (existingTypes.length > 0) {\n        return res.json({ message: \"Data already seeded\" });\n      }\n\n      const bankType = await storage.createLocationType({ name: \"Bank\", icon: \"credit-card\" });\n      const hospitalType = await storage.createLocationType({ name: \"Hospital\", icon: \"activity\" });\n      const govType = await storage.createLocationType({ name: \"Government Office\", icon: \"briefcase\" });\n\n      const sampleLocations = [\n        { name: \"First National Bank - Downtown\", address: \"123 Main Street, Downtown\", typeId: bankType.id, averageServiceTime: 8 },\n        { name: \"City Hospital - Emergency\", address: \"456 Health Ave, Medical District\", typeId: hospitalType.id, averageServiceTime: 15 },\n        { name: \"DMV - Central Office\", address: \"789 Government Blvd, Civic Center\", typeId: govType.id, averageServiceTime: 12 },\n        { name: \"Chase Bank - Mall Branch\", address: \"321 Shopping Center Dr\", typeId: bankType.id, averageServiceTime: 6 },\n        { name: \"Community Clinic\", address: \"555 Wellness Way\", typeId: hospitalType.id, averageServiceTime: 10 },\n        { name: \"Social Security Office\", address: \"888 Federal Plaza\", typeId: govType.id, averageServiceTime: 20 },\n      ];\n\n      for (const loc of sampleLocations) {\n        await storage.createLocation(loc);\n      }\n\n      res.json({ message: \"Seed data created successfully\" });\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to seed data\" });\n    }\n  });\n\n  const httpServer = createServer(app);\n  return httpServer;\n}\n","path":null,"size_bytes":5458,"size_tokens":null},"Mobile-Architect/eslint.config.js":{"content":"// https://docs.expo.dev/guides/using-eslint/\nconst { defineConfig } = require(\"eslint/config\");\nconst expoConfig = require(\"eslint-config-expo/flat\");\nconst eslintPluginPrettierRecommended = require(\"eslint-plugin-prettier/recommended\");\n\nmodule.exports = defineConfig([\n  expoConfig,\n  eslintPluginPrettierRecommended,\n  {\n    ignores: [\"dist/*\"],\n  },\n]);\n","path":null,"size_bytes":359,"size_tokens":null},"Mobile-Architect/client/navigation/RootStackNavigator.tsx":{"content":"import React from \"react\";\nimport { createNativeStackNavigator } from \"@react-navigation/native-stack\";\nimport MainTabNavigator from \"@/navigation/MainTabNavigator\";\nimport CheckinModal from \"@/screens/CheckinModal\";\nimport { useScreenOptions } from \"@/hooks/useScreenOptions\";\n\nexport type RootStackParamList = {\n  Main: undefined;\n  CheckinModal: { locationId: string; locationName: string };\n};\n\nconst Stack = createNativeStackNavigator<RootStackParamList>();\n\nexport default function RootStackNavigator() {\n  const screenOptions = useScreenOptions();\n\n  return (\n    <Stack.Navigator screenOptions={screenOptions}>\n      <Stack.Screen\n        name=\"Main\"\n        component={MainTabNavigator}\n        options={{ headerShown: false }}\n      />\n      <Stack.Screen\n        name=\"CheckinModal\"\n        component={CheckinModal}\n        options={{\n          presentation: \"modal\",\n          headerTitle: \"Check In\",\n        }}\n      />\n    </Stack.Navigator>\n  );\n}\n","path":null,"size_bytes":964,"size_tokens":null},"Mobile-Architect/client/App.tsx":{"content":"import React from \"react\";\nimport { StyleSheet } from \"react-native\";\nimport { NavigationContainer } from \"@react-navigation/native\";\nimport { GestureHandlerRootView } from \"react-native-gesture-handler\";\nimport { KeyboardProvider } from \"react-native-keyboard-controller\";\nimport { SafeAreaProvider } from \"react-native-safe-area-context\";\nimport { StatusBar } from \"expo-status-bar\";\n\nimport { QueryClientProvider } from \"@tanstack/react-query\";\nimport { queryClient } from \"@/lib/query-client\";\n\nimport RootStackNavigator from \"@/navigation/RootStackNavigator\";\nimport { ErrorBoundary } from \"@/components/ErrorBoundary\";\n\nexport default function App() {\n  return (\n    <ErrorBoundary>\n      <QueryClientProvider client={queryClient}>\n        <SafeAreaProvider>\n          <GestureHandlerRootView style={styles.root}>\n            <KeyboardProvider>\n              <NavigationContainer>\n                <RootStackNavigator />\n              </NavigationContainer>\n              <StatusBar style=\"auto\" />\n            </KeyboardProvider>\n          </GestureHandlerRootView>\n        </SafeAreaProvider>\n      </QueryClientProvider>\n    </ErrorBoundary>\n  );\n}\n\nconst styles = StyleSheet.create({\n  root: {\n    flex: 1,\n  },\n});\n","path":null,"size_bytes":1225,"size_tokens":null},"Mobile-Architect/client/hooks/useTheme.ts":{"content":"import { Colors } from \"@/constants/theme\";\nimport { useColorScheme } from \"@/hooks/useColorScheme\";\n\nexport function useTheme() {\n  const colorScheme = useColorScheme();\n  const isDark = colorScheme === \"dark\";\n  const theme = Colors[colorScheme ?? \"light\"];\n\n  return {\n    theme,\n    isDark,\n  };\n}\n","path":null,"size_bytes":302,"size_tokens":null},"Mobile-Architect/client/components/ThemedText.tsx":{"content":"import { Text, type TextProps } from \"react-native\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Typography } from \"@/constants/theme\";\n\nexport type ThemedTextProps = TextProps & {\n  lightColor?: string;\n  darkColor?: string;\n  type?: \"h1\" | \"h2\" | \"h3\" | \"h4\" | \"body\" | \"small\" | \"link\";\n};\n\nexport function ThemedText({\n  style,\n  lightColor,\n  darkColor,\n  type = \"body\",\n  ...rest\n}: ThemedTextProps) {\n  const { theme, isDark } = useTheme();\n\n  const getColor = () => {\n    if (isDark && darkColor) {\n      return darkColor;\n    }\n\n    if (!isDark && lightColor) {\n      return lightColor;\n    }\n\n    if (type === \"link\") {\n      return theme.link;\n    }\n\n    return theme.text;\n  };\n\n  const getTypeStyle = () => {\n    switch (type) {\n      case \"h1\":\n        return Typography.h1;\n      case \"h2\":\n        return Typography.h2;\n      case \"h3\":\n        return Typography.h3;\n      case \"h4\":\n        return Typography.h4;\n      case \"body\":\n        return Typography.body;\n      case \"small\":\n        return Typography.small;\n      case \"link\":\n        return Typography.link;\n      default:\n        return Typography.body;\n    }\n  };\n\n  return (\n    <Text style={[{ color: getColor() }, getTypeStyle(), style]} {...rest} />\n  );\n}\n","path":null,"size_bytes":1251,"size_tokens":null},"Mobile-Architect/client/components/Spacer.tsx":{"content":"import { View } from \"react-native\";\n\ntype Props = {\n  width?: number;\n  height?: number;\n};\n\nexport default function Spacer(props: Props) {\n  const width: number = props.width ?? 1;\n  const height: number = props.height ?? 1;\n\n  return (\n    <View\n      style={{\n        width,\n        height,\n      }}\n    />\n  );\n}\n","path":null,"size_bytes":318,"size_tokens":null},"Mobile-Architect/client/components/EmptyState.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet } from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing } from \"@/constants/theme\";\n\ninterface EmptyStateProps {\n  icon: string;\n  title: string;\n  description?: string;\n}\n\nexport function EmptyState({ icon, title, description }: EmptyStateProps) {\n  const { theme } = useTheme();\n\n  return (\n    <View style={styles.container}>\n      <View style={[styles.iconContainer, { backgroundColor: theme.backgroundDefault }]}>\n        <Feather name={icon as any} size={48} color={theme.primary} />\n      </View>\n      <ThemedText style={styles.title}>{title}</ThemedText>\n      {description ? (\n        <ThemedText style={[styles.description, { color: theme.textSecondary }]}>\n          {description}\n        </ThemedText>\n      ) : null}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    padding: Spacing[\"3xl\"],\n  },\n  iconContainer: {\n    width: 100,\n    height: 100,\n    borderRadius: 50,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    marginBottom: Spacing.xl,\n  },\n  title: {\n    fontSize: 18,\n    fontWeight: \"600\",\n    textAlign: \"center\",\n    marginBottom: Spacing.sm,\n  },\n  description: {\n    fontSize: 14,\n    textAlign: \"center\",\n    maxWidth: 280,\n  },\n});\n","path":null,"size_bytes":1438,"size_tokens":null},"Mobile-Architect/client/hooks/useColorScheme.ts":{"content":"export { useColorScheme } from \"react-native\";\n","path":null,"size_bytes":47,"size_tokens":null},"Mobile-Architect/client/components/NumberStepper.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet, Pressable } from \"react-native\";\nimport Animated, { useAnimatedStyle, useSharedValue, withSpring } from \"react-native-reanimated\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\n\ninterface NumberStepperProps {\n  value: number;\n  onChange: (value: number) => void;\n  min?: number;\n  max?: number;\n  step?: number;\n}\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nfunction StepButton({ icon, onPress, disabled }: { icon: string; onPress: () => void; disabled: boolean }) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handlePressIn = () => {\n    if (!disabled) {\n      scale.value = withSpring(0.9, { damping: 15, stiffness: 150 });\n    }\n  };\n\n  const handlePressOut = () => {\n    scale.value = withSpring(1, { damping: 15, stiffness: 150 });\n  };\n\n  return (\n    <AnimatedPressable\n      onPress={disabled ? undefined : onPress}\n      onPressIn={handlePressIn}\n      onPressOut={handlePressOut}\n      style={[\n        styles.button,\n        { backgroundColor: disabled ? theme.backgroundSecondary : theme.primary },\n        animatedStyle,\n      ]}\n    >\n      <Feather name={icon as any} size={24} color={disabled ? theme.textDisabled : \"#FFFFFF\"} />\n    </AnimatedPressable>\n  );\n}\n\nexport function NumberStepper({ value, onChange, min = 0, max = 200, step = 1 }: NumberStepperProps) {\n  const { theme } = useTheme();\n\n  const handleDecrement = () => {\n    const newValue = Math.max(min, value - step);\n    onChange(newValue);\n  };\n\n  const handleIncrement = () => {\n    const newValue = Math.min(max, value + step);\n    onChange(newValue);\n  };\n\n  return (\n    <View style={styles.container}>\n      <StepButton icon=\"minus\" onPress={handleDecrement} disabled={value <= min} />\n      <View style={[styles.valueContainer, { backgroundColor: theme.backgroundDefault }]}>\n        <ThemedText style={styles.value}>{value}</ThemedText>\n      </View>\n      <StepButton icon=\"plus\" onPress={handleIncrement} disabled={value >= max} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.md,\n  },\n  button: {\n    width: 48,\n    height: 48,\n    borderRadius: BorderRadius.md,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  valueContainer: {\n    minWidth: 80,\n    height: 48,\n    borderRadius: BorderRadius.md,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    paddingHorizontal: Spacing.lg,\n  },\n  value: {\n    fontSize: 24,\n    fontWeight: \"700\",\n  },\n});\n","path":null,"size_bytes":2829,"size_tokens":null},"Mobile-Architect/client/components/KeyboardAwareScrollViewCompat.tsx":{"content":"import { Platform, ScrollView, ScrollViewProps } from \"react-native\";\nimport {\n  KeyboardAwareScrollView,\n  KeyboardAwareScrollViewProps,\n} from \"react-native-keyboard-controller\";\n\ntype Props = KeyboardAwareScrollViewProps & ScrollViewProps;\n\n/**\n * KeyboardAwareScrollView that falls back to ScrollView on web.\n * Use this for any screen containing text inputs.\n */\nexport function KeyboardAwareScrollViewCompat({\n  children,\n  keyboardShouldPersistTaps = \"handled\",\n  ...props\n}: Props) {\n  if (Platform.OS === \"web\") {\n    return (\n      <ScrollView\n        keyboardShouldPersistTaps={keyboardShouldPersistTaps}\n        {...props}\n      >\n        {children}\n      </ScrollView>\n    );\n  }\n\n  return (\n    <KeyboardAwareScrollView\n      keyboardShouldPersistTaps={keyboardShouldPersistTaps}\n      {...props}\n    >\n      {children}\n    </KeyboardAwareScrollView>\n  );\n}\n","path":null,"size_bytes":872,"size_tokens":null},"Mobile-Architect/client/screens/HomeScreen.tsx":{"content":"import React, { useState, useEffect, useCallback } from \"react\";\nimport { View, FlatList, ScrollView, RefreshControl, StyleSheet, ActivityIndicator } from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useHeaderHeight } from \"@react-navigation/elements\";\nimport { useBottomTabBarHeight } from \"@react-navigation/bottom-tabs\";\nimport { useNavigation, useFocusEffect } from \"@react-navigation/native\";\nimport { NativeStackNavigationProp } from \"@react-navigation/native-stack\";\nimport { useQuery, useMutation } from \"@tanstack/react-query\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { CategoryChip } from \"@/components/CategoryChip\";\nimport { LocationCard } from \"@/components/LocationCard\";\nimport { FloatingActionButton } from \"@/components/FloatingActionButton\";\nimport { EmptyState } from \"@/components/EmptyState\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing } from \"@/constants/theme\";\nimport { apiRequest, queryClient } from \"@/lib/query-client\";\nimport { HomeStackParamList } from \"@/navigation/HomeStackNavigator\";\nimport { RootStackParamList } from \"@/navigation/RootStackNavigator\";\n\ntype LocationType = {\n  id: string;\n  name: string;\n  icon: string;\n};\n\ntype Location = {\n  id: string;\n  name: string;\n  address: string;\n  typeId: string;\n};\n\ntype QueueStatus = {\n  estimatedWaitTime: number;\n  currentQueueSize: number;\n};\n\nexport default function HomeScreen() {\n  const insets = useSafeAreaInsets();\n  const headerHeight = useHeaderHeight();\n  const tabBarHeight = useBottomTabBarHeight();\n  const { theme } = useTheme();\n  const navigation = useNavigation<NativeStackNavigationProp<HomeStackParamList & RootStackParamList>>();\n  \n  const [selectedType, setSelectedType] = useState<string | null>(null);\n  const [queueStatuses, setQueueStatuses] = useState<Record<string, QueueStatus>>({});\n  const [refreshing, setRefreshing] = useState(false);\n\n  const { data: locationTypes = [], isLoading: typesLoading } = useQuery<LocationType[]>({\n    queryKey: [\"/api/location-types\"],\n  });\n\n  const { data: locations = [], isLoading: locationsLoading, refetch: refetchLocations } = useQuery<Location[]>({\n    queryKey: [\"/api/locations\", selectedType ? `typeId=${selectedType}` : \"\"].filter(Boolean),\n  });\n\n  const seedMutation = useMutation({\n    mutationFn: async () => {\n      return apiRequest(\"POST\", \"/api/seed\");\n    },\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: [\"/api/location-types\"] });\n      queryClient.invalidateQueries({ queryKey: [\"/api/locations\"] });\n    },\n  });\n\n  useEffect(() => {\n    if (!typesLoading && locationTypes.length === 0) {\n      seedMutation.mutate();\n    }\n  }, [typesLoading, locationTypes.length]);\n\n  const fetchQueueStatuses = useCallback(async () => {\n    const statuses: Record<string, QueueStatus> = {};\n    for (const loc of locations) {\n      try {\n        const res = await fetch(`${process.env.EXPO_PUBLIC_DOMAIN ? `https://${process.env.EXPO_PUBLIC_DOMAIN}` : \"\"}/api/locations/${loc.id}/queue-status`);\n        if (res.ok) {\n          const data = await res.json();\n          statuses[loc.id] = {\n            estimatedWaitTime: data.estimatedWaitTime,\n            currentQueueSize: data.currentQueueSize,\n          };\n        }\n      } catch {}\n    }\n    setQueueStatuses(statuses);\n  }, [locations]);\n\n  useFocusEffect(\n    useCallback(() => {\n      if (locations.length > 0) {\n        fetchQueueStatuses();\n      }\n    }, [locations, fetchQueueStatuses])\n  );\n\n  const handleRefresh = async () => {\n    setRefreshing(true);\n    await refetchLocations();\n    await fetchQueueStatuses();\n    setRefreshing(false);\n  };\n\n  const filteredLocations = selectedType\n    ? locations.filter((loc) => loc.typeId === selectedType)\n    : locations;\n\n  const handleLocationPress = (location: Location) => {\n    navigation.navigate(\"QueueStatus\", { locationId: location.id, locationName: location.name });\n  };\n\n  const handleFabPress = () => {\n    if (filteredLocations.length > 0) {\n      const firstLocation = filteredLocations[0];\n      navigation.navigate(\"CheckinModal\", { locationId: firstLocation.id, locationName: firstLocation.name });\n    }\n  };\n\n  const isLoading = typesLoading || locationsLoading || seedMutation.isPending;\n\n  return (\n    <View style={[styles.container, { backgroundColor: theme.backgroundRoot }]}>\n      <FlatList\n        style={styles.list}\n        contentContainerStyle={{\n          paddingTop: headerHeight + Spacing.xl,\n          paddingBottom: tabBarHeight + Spacing[\"4xl\"],\n          paddingHorizontal: Spacing.lg,\n          flexGrow: 1,\n        }}\n        scrollIndicatorInsets={{ bottom: insets.bottom }}\n        refreshControl={\n          <RefreshControl refreshing={refreshing} onRefresh={handleRefresh} tintColor={theme.primary} />\n        }\n        ListHeaderComponent={\n          <View style={styles.header}>\n            <ThemedText type=\"h3\" style={styles.sectionTitle}>\n              Find a Location\n            </ThemedText>\n            <ScrollView\n              horizontal\n              showsHorizontalScrollIndicator={false}\n              style={styles.categories}\n              contentContainerStyle={styles.categoriesContent}\n            >\n              <CategoryChip\n                label=\"All\"\n                icon=\"grid\"\n                isSelected={selectedType === null}\n                onPress={() => setSelectedType(null)}\n              />\n              {locationTypes.map((type) => (\n                <CategoryChip\n                  key={type.id}\n                  label={type.name}\n                  icon={type.icon}\n                  isSelected={selectedType === type.id}\n                  onPress={() => setSelectedType(type.id)}\n                />\n              ))}\n            </ScrollView>\n            <ThemedText type=\"small\" style={[styles.resultsText, { color: theme.textSecondary }]}>\n              {filteredLocations.length} location{filteredLocations.length !== 1 ? \"s\" : \"\"} found\n            </ThemedText>\n          </View>\n        }\n        data={filteredLocations}\n        keyExtractor={(item) => item.id}\n        renderItem={({ item }) => (\n          <LocationCard\n            name={item.name}\n            address={item.address}\n            waitTime={queueStatuses[item.id]?.estimatedWaitTime}\n            queueSize={queueStatuses[item.id]?.currentQueueSize}\n            onPress={() => handleLocationPress(item)}\n          />\n        )}\n        ListEmptyComponent={\n          isLoading ? (\n            <View style={styles.loadingContainer}>\n              <ActivityIndicator size=\"large\" color={theme.primary} />\n              <ThemedText style={[styles.loadingText, { color: theme.textSecondary }]}>\n                Loading locations...\n              </ThemedText>\n            </View>\n          ) : (\n            <EmptyState\n              icon=\"map-pin\"\n              title=\"No Locations Found\"\n              description=\"Check back later or try a different category.\"\n            />\n          )\n        }\n      />\n      {filteredLocations.length > 0 ? (\n        <FloatingActionButton\n          onPress={handleFabPress}\n          icon=\"plus\"\n          style={{ bottom: tabBarHeight + Spacing.xl }}\n        />\n      ) : null}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  list: {\n    flex: 1,\n  },\n  header: {\n    marginBottom: Spacing.lg,\n  },\n  sectionTitle: {\n    marginBottom: Spacing.lg,\n  },\n  categories: {\n    marginBottom: Spacing.md,\n    marginHorizontal: -Spacing.lg,\n  },\n  categoriesContent: {\n    paddingHorizontal: Spacing.lg,\n  },\n  resultsText: {\n    marginTop: Spacing.sm,\n  },\n  loadingContainer: {\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    paddingVertical: Spacing[\"5xl\"],\n  },\n  loadingText: {\n    marginTop: Spacing.md,\n  },\n});\n","path":null,"size_bytes":7844,"size_tokens":null},"Mobile-Architect/client/screens/HistoryScreen.tsx":{"content":"import React, { useState, useCallback } from \"react\";\nimport { View, ScrollView, FlatList, RefreshControl, StyleSheet, Pressable, Alert } from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useHeaderHeight } from \"@react-navigation/elements\";\nimport { useBottomTabBarHeight } from \"@react-navigation/bottom-tabs\";\nimport { useFocusEffect, useNavigation } from \"@react-navigation/native\";\nimport { NativeStackNavigationProp } from \"@react-navigation/native-stack\";\nimport { Feather } from \"@expo/vector-icons\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { Card } from \"@/components/Card\";\nimport { EmptyState } from \"@/components/EmptyState\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\nimport { getSavedLocations, getRecentCheckins, removeSavedLocation, SavedLocation, RecentCheckin } from \"@/lib/storage\";\nimport { HomeStackParamList } from \"@/navigation/HomeStackNavigator\";\n\nexport default function HistoryScreen() {\n  const insets = useSafeAreaInsets();\n  const headerHeight = useHeaderHeight();\n  const tabBarHeight = useBottomTabBarHeight();\n  const { theme } = useTheme();\n  const navigation = useNavigation<NativeStackNavigationProp<HomeStackParamList>>();\n  \n  const [savedLocations, setSavedLocations] = useState<SavedLocation[]>([]);\n  const [recentCheckins, setRecentCheckins] = useState<RecentCheckin[]>([]);\n  const [refreshing, setRefreshing] = useState(false);\n\n  const loadData = useCallback(async () => {\n    const [locations, checkins] = await Promise.all([\n      getSavedLocations(),\n      getRecentCheckins(),\n    ]);\n    setSavedLocations(locations);\n    setRecentCheckins(checkins);\n  }, []);\n\n  useFocusEffect(\n    useCallback(() => {\n      loadData();\n    }, [loadData])\n  );\n\n  const handleRefresh = async () => {\n    setRefreshing(true);\n    await loadData();\n    setRefreshing(false);\n  };\n\n  const handleRemoveSaved = (locationId: string, locationName: string) => {\n    Alert.alert(\n      \"Remove Location\",\n      `Remove ${locationName} from saved locations?`,\n      [\n        { text: \"Cancel\", style: \"cancel\" },\n        {\n          text: \"Remove\",\n          style: \"destructive\",\n          onPress: async () => {\n            await removeSavedLocation(locationId);\n            loadData();\n          },\n        },\n      ]\n    );\n  };\n\n  const handleLocationPress = (location: SavedLocation) => {\n    navigation.navigate(\"QueueStatus\", { locationId: location.id, locationName: location.name });\n  };\n\n  const formatDate = (isoString: string) => {\n    const date = new Date(isoString);\n    const now = new Date();\n    const diffMs = now.getTime() - date.getTime();\n    const diffMins = Math.floor(diffMs / 60000);\n    const diffHours = Math.floor(diffMs / 3600000);\n    const diffDays = Math.floor(diffMs / 86400000);\n\n    if (diffMins < 60) return `${diffMins}m ago`;\n    if (diffHours < 24) return `${diffHours}h ago`;\n    if (diffDays < 7) return `${diffDays}d ago`;\n    return date.toLocaleDateString();\n  };\n\n  const isEmpty = savedLocations.length === 0 && recentCheckins.length === 0;\n\n  return (\n    <ScrollView\n      style={[styles.container, { backgroundColor: theme.backgroundRoot }]}\n      contentContainerStyle={{\n        paddingTop: headerHeight + Spacing.xl,\n        paddingBottom: tabBarHeight + Spacing[\"3xl\"],\n        paddingHorizontal: Spacing.lg,\n        flexGrow: 1,\n      }}\n      refreshControl={\n        <RefreshControl refreshing={refreshing} onRefresh={handleRefresh} tintColor={theme.primary} />\n      }\n    >\n      {isEmpty ? (\n        <View style={styles.emptyContainer}>\n          <EmptyState\n            icon=\"clock\"\n            title=\"No Activity Yet\"\n            description=\"Your saved locations and recent check-ins will appear here.\"\n          />\n        </View>\n      ) : (\n        <>\n          {savedLocations.length > 0 ? (\n            <View style={styles.section}>\n              <ThemedText type=\"h4\" style={styles.sectionTitle}>\n                Saved Locations\n              </ThemedText>\n              <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.savedList}>\n                {savedLocations.map((location) => (\n                  <Pressable\n                    key={location.id}\n                    onPress={() => handleLocationPress(location)}\n                    onLongPress={() => handleRemoveSaved(location.id, location.name)}\n                  >\n                    <Card elevation={1} style={styles.savedCard}>\n                      <View style={[styles.savedIcon, { backgroundColor: theme.primary + \"20\" }]}>\n                        <Feather name=\"heart\" size={16} color={theme.primary} />\n                      </View>\n                      <ThemedText style={styles.savedName} numberOfLines={1}>\n                        {location.name}\n                      </ThemedText>\n                      <ThemedText style={[styles.savedAddress, { color: theme.textSecondary }]} numberOfLines={1}>\n                        {location.address}\n                      </ThemedText>\n                    </Card>\n                  </Pressable>\n                ))}\n              </ScrollView>\n              <ThemedText style={[styles.hint, { color: theme.textSecondary }]}>\n                Long press to remove\n              </ThemedText>\n            </View>\n          ) : null}\n\n          <View style={styles.section}>\n            <ThemedText type=\"h4\" style={styles.sectionTitle}>\n              Recent Check-ins\n            </ThemedText>\n            {recentCheckins.length > 0 ? (\n              recentCheckins.map((checkin, index) => (\n                <Card key={checkin.id || index} elevation={1} style={styles.checkinCard}>\n                  <View style={styles.checkinHeader}>\n                    <View style={[styles.checkinIcon, { backgroundColor: theme.success + \"20\" }]}>\n                      <Feather name=\"check\" size={16} color={theme.success} />\n                    </View>\n                    <View style={styles.checkinInfo}>\n                      <ThemedText style={styles.checkinLocation}>{checkin.locationName}</ThemedText>\n                      <ThemedText style={[styles.checkinTime, { color: theme.textSecondary }]}>\n                        {formatDate(checkin.createdAt)}\n                      </ThemedText>\n                    </View>\n                    <View style={[styles.queueBadge, { backgroundColor: theme.backgroundSecondary }]}>\n                      <ThemedText style={styles.queueNumber}>{checkin.peopleAhead}</ThemedText>\n                      <ThemedText style={[styles.queueLabel, { color: theme.textSecondary }]}>ahead</ThemedText>\n                    </View>\n                  </View>\n                </Card>\n              ))\n            ) : (\n              <Card elevation={1} style={styles.emptyCard}>\n                <ThemedText style={[styles.emptyText, { color: theme.textSecondary }]}>\n                  No check-ins yet. Visit a location and check in to help others!\n                </ThemedText>\n              </Card>\n            )}\n          </View>\n        </>\n      )}\n    </ScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  emptyContainer: {\n    flex: 1,\n    justifyContent: \"center\",\n  },\n  section: {\n    marginBottom: Spacing[\"2xl\"],\n  },\n  sectionTitle: {\n    marginBottom: Spacing.md,\n  },\n  savedList: {\n    marginHorizontal: -Spacing.lg,\n    paddingHorizontal: Spacing.lg,\n  },\n  savedCard: {\n    width: 160,\n    marginRight: Spacing.md,\n    padding: Spacing.lg,\n  },\n  savedIcon: {\n    width: 32,\n    height: 32,\n    borderRadius: BorderRadius.sm,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    marginBottom: Spacing.sm,\n  },\n  savedName: {\n    fontSize: 14,\n    fontWeight: \"600\",\n    marginBottom: 4,\n  },\n  savedAddress: {\n    fontSize: 12,\n  },\n  hint: {\n    fontSize: 12,\n    marginTop: Spacing.sm,\n    textAlign: \"center\",\n  },\n  checkinCard: {\n    marginBottom: Spacing.md,\n    padding: Spacing.lg,\n  },\n  checkinHeader: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n  },\n  checkinIcon: {\n    width: 36,\n    height: 36,\n    borderRadius: BorderRadius.sm,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    marginRight: Spacing.md,\n  },\n  checkinInfo: {\n    flex: 1,\n  },\n  checkinLocation: {\n    fontSize: 14,\n    fontWeight: \"500\",\n  },\n  checkinTime: {\n    fontSize: 12,\n    marginTop: 2,\n  },\n  queueBadge: {\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.md,\n    paddingVertical: Spacing.sm,\n    borderRadius: BorderRadius.sm,\n  },\n  queueNumber: {\n    fontSize: 18,\n    fontWeight: \"700\",\n  },\n  queueLabel: {\n    fontSize: 10,\n  },\n  emptyCard: {\n    padding: Spacing.xl,\n    alignItems: \"center\",\n  },\n  emptyText: {\n    fontSize: 14,\n    textAlign: \"center\",\n  },\n});\n","path":null,"size_bytes":8837,"size_tokens":null}},"version":2}